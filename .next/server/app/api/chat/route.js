"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/chat/route";
exports.ids = ["app/api/chat/route"];
exports.modules = {

/***/ "mongodb":
/*!**************************!*\
  !*** external "mongodb" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("mongodb");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

module.exports = require("https");

/***/ }),

/***/ "node:fs":
/*!**************************!*\
  !*** external "node:fs" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("node:fs");

/***/ }),

/***/ "node:stream":
/*!******************************!*\
  !*** external "node:stream" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("node:stream");

/***/ }),

/***/ "node:stream/web":
/*!**********************************!*\
  !*** external "node:stream/web" ***!
  \**********************************/
/***/ ((module) => {

module.exports = require("node:stream/web");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "punycode":
/*!***************************!*\
  !*** external "punycode" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("punycode");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("stream");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");

/***/ }),

/***/ "worker_threads":
/*!*********************************!*\
  !*** external "worker_threads" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("worker_threads");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("zlib");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fchat%2Froute&page=%2Fapi%2Fchat%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fchat%2Froute.ts&appDir=C%3A%5CUsers%5CDeborah%5CDocuments%5CCursor%20Projects%5Cchatpye%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CDeborah%5CDocuments%5CCursor%20Projects%5Cchatpye&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!":
/*!****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fchat%2Froute&page=%2Fapi%2Fchat%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fchat%2Froute.ts&appDir=C%3A%5CUsers%5CDeborah%5CDocuments%5CCursor%20Projects%5Cchatpye%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CDeborah%5CDocuments%5CCursor%20Projects%5Cchatpye&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D! ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   headerHooks: () => (/* binding */ headerHooks),\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage),\n/* harmony export */   staticGenerationBailout: () => (/* binding */ staticGenerationBailout)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var C_Users_Deborah_Documents_Cursor_Projects_chatpye_src_app_api_chat_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/app/api/chat/route.ts */ \"(rsc)/./src/app/api/chat/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"standalone\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/chat/route\",\n        pathname: \"/api/chat\",\n        filename: \"route\",\n        bundlePath: \"app/api/chat/route\"\n    },\n    resolvedPagePath: \"C:\\\\Users\\\\Deborah\\\\Documents\\\\Cursor Projects\\\\chatpye\\\\src\\\\app\\\\api\\\\chat\\\\route.ts\",\n    nextConfigOutput,\n    userland: C_Users_Deborah_Documents_Cursor_Projects_chatpye_src_app_api_chat_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks, headerHooks, staticGenerationBailout } = routeModule;\nconst originalPathname = \"/api/chat/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZjaGF0JTJGcm91dGUmcGFnZT0lMkZhcGklMkZjaGF0JTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGY2hhdCUyRnJvdXRlLnRzJmFwcERpcj1DJTNBJTVDVXNlcnMlNUNEZWJvcmFoJTVDRG9jdW1lbnRzJTVDQ3Vyc29yJTIwUHJvamVjdHMlNUNjaGF0cHllJTVDc3JjJTVDYXBwJnBhZ2VFeHRlbnNpb25zPXRzeCZwYWdlRXh0ZW5zaW9ucz10cyZwYWdlRXh0ZW5zaW9ucz1qc3gmcGFnZUV4dGVuc2lvbnM9anMmcm9vdERpcj1DJTNBJTVDVXNlcnMlNUNEZWJvcmFoJTVDRG9jdW1lbnRzJTVDQ3Vyc29yJTIwUHJvamVjdHMlNUNjaGF0cHllJmlzRGV2PXRydWUmdHNjb25maWdQYXRoPXRzY29uZmlnLmpzb24mYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PXN0YW5kYWxvbmUmcHJlZmVycmVkUmVnaW9uPSZtaWRkbGV3YXJlQ29uZmlnPWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBc0c7QUFDdkM7QUFDYztBQUNzQztBQUNuSDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0hBQW1CO0FBQzNDO0FBQ0EsY0FBYyx5RUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWTtBQUNaLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVHQUF1RztBQUMvRztBQUNBO0FBQ0EsV0FBVyw0RUFBVztBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQzZKOztBQUU3SiIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRweWUvP2Q4NjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBwUm91dGVSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL2FwcC1yb3V0ZS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBwYXRjaEZldGNoIGFzIF9wYXRjaEZldGNoIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3BhdGNoLWZldGNoXCI7XG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiQzpcXFxcVXNlcnNcXFxcRGVib3JhaFxcXFxEb2N1bWVudHNcXFxcQ3Vyc29yIFByb2plY3RzXFxcXGNoYXRweWVcXFxcc3JjXFxcXGFwcFxcXFxhcGlcXFxcY2hhdFxcXFxyb3V0ZS50c1wiO1xuLy8gV2UgaW5qZWN0IHRoZSBuZXh0Q29uZmlnT3V0cHV0IGhlcmUgc28gdGhhdCB3ZSBjYW4gdXNlIHRoZW0gaW4gdGhlIHJvdXRlXG4vLyBtb2R1bGUuXG5jb25zdCBuZXh0Q29uZmlnT3V0cHV0ID0gXCJzdGFuZGFsb25lXCJcbmNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IEFwcFJvdXRlUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLkFQUF9ST1VURSxcbiAgICAgICAgcGFnZTogXCIvYXBpL2NoYXQvcm91dGVcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9jaGF0XCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS9jaGF0L3JvdXRlXCJcbiAgICB9LFxuICAgIHJlc29sdmVkUGFnZVBhdGg6IFwiQzpcXFxcVXNlcnNcXFxcRGVib3JhaFxcXFxEb2N1bWVudHNcXFxcQ3Vyc29yIFByb2plY3RzXFxcXGNoYXRweWVcXFxcc3JjXFxcXGFwcFxcXFxhcGlcXFxcY2hhdFxcXFxyb3V0ZS50c1wiLFxuICAgIG5leHRDb25maWdPdXRwdXQsXG4gICAgdXNlcmxhbmRcbn0pO1xuLy8gUHVsbCBvdXQgdGhlIGV4cG9ydHMgdGhhdCB3ZSBuZWVkIHRvIGV4cG9zZSBmcm9tIHRoZSBtb2R1bGUuIFRoaXMgc2hvdWxkXG4vLyBiZSBlbGltaW5hdGVkIHdoZW4gd2UndmUgbW92ZWQgdGhlIG90aGVyIHJvdXRlcyB0byB0aGUgbmV3IGZvcm1hdC4gVGhlc2Vcbi8vIGFyZSB1c2VkIHRvIGhvb2sgaW50byB0aGUgcm91dGUuXG5jb25zdCB7IHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzLCBoZWFkZXJIb29rcywgc3RhdGljR2VuZXJhdGlvbkJhaWxvdXQgfSA9IHJvdXRlTW9kdWxlO1xuY29uc3Qgb3JpZ2luYWxQYXRobmFtZSA9IFwiL2FwaS9jaGF0L3JvdXRlXCI7XG5mdW5jdGlvbiBwYXRjaEZldGNoKCkge1xuICAgIHJldHVybiBfcGF0Y2hGZXRjaCh7XG4gICAgICAgIHNlcnZlckhvb2tzLFxuICAgICAgICBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlXG4gICAgfSk7XG59XG5leHBvcnQgeyByb3V0ZU1vZHVsZSwgcmVxdWVzdEFzeW5jU3RvcmFnZSwgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MsIGhlYWRlckhvb2tzLCBzdGF0aWNHZW5lcmF0aW9uQmFpbG91dCwgb3JpZ2luYWxQYXRobmFtZSwgcGF0Y2hGZXRjaCwgIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fchat%2Froute&page=%2Fapi%2Fchat%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fchat%2Froute.ts&appDir=C%3A%5CUsers%5CDeborah%5CDocuments%5CCursor%20Projects%5Cchatpye%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CDeborah%5CDocuments%5CCursor%20Projects%5Cchatpye&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./src/app/api/chat/route.ts":
/*!***********************************!*\
  !*** ./src/app/api/chat/route.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/web/exports/next-response */ \"(rsc)/./node_modules/next/dist/server/web/exports/next-response.js\");\n/* harmony import */ var _lib_mongodb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/mongodb */ \"(rsc)/./src/lib/mongodb.ts\");\n/* harmony import */ var _lib_embeddings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/embeddings */ \"(rsc)/./src/lib/embeddings.ts\");\n/* harmony import */ var _lib_openai__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/openai */ \"(rsc)/./src/lib/openai.ts\");\n/* harmony import */ var _lib_anthropic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/lib/anthropic */ \"(rsc)/./src/lib/anthropic.ts\");\n/* harmony import */ var _lib_gemini__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/lib/gemini */ \"(rsc)/./src/lib/gemini.ts\");\n\n\n\n\n\n\n// Helper to normalize questions for consistent cache keys\nfunction normalizeQuestion(question) {\n    return question.toLowerCase().trim().replace(/\\s+/g, \" \");\n}\n// Utility to convert AsyncIterable<string> to ReadableStream<Uint8Array>\n// and call an onComplete callback with the accumulated text.\nasync function processStreamForResponseAndCache(streamGenerator, onComplete) {\n    let accumulatedText = \"\";\n    const encoder = new TextEncoder();\n    let streamClosed = false; // Flag to prevent multiple onComplete calls\n    const readableStream = new ReadableStream({\n        async pull (controller) {\n            try {\n                const { value, done } = await streamGenerator.next();\n                if (done) {\n                    if (!streamClosed) {\n                        streamClosed = true;\n                        controller.close();\n                        // Call onComplete asynchronously without blocking stream closure\n                        onComplete(accumulatedText).catch((cacheError)=>{\n                            console.error(\"Error saving to cache post-stream:\", cacheError);\n                        });\n                    }\n                } else {\n                    accumulatedText += value;\n                    controller.enqueue(encoder.encode(value));\n                }\n            } catch (error) {\n                console.error(\"Error in stream generator during pull:\", error);\n                if (!streamClosed) {\n                    streamClosed = true;\n                    controller.error(error); // Propagate error to the stream consumer\n                }\n            }\n        },\n        async cancel (reason) {\n            console.log(\"Stream cancelled by client:\", reason);\n            if (!streamClosed) {\n                streamClosed = true;\n                if (typeof streamGenerator.return === \"function\") {\n                    try {\n                        await streamGenerator.return(undefined); // Ensure generator cleanup\n                    } catch (genError) {\n                        console.error(\"Error during generator return on cancel:\", genError);\n                    }\n                }\n            }\n        }\n    });\n    return readableStream;\n}\n// Add this function at the top level\nasync function validateTranscriptChunks(chunks, videoId, userId) {\n    if (!chunks || chunks.length === 0) {\n        console.log(\"No transcript chunks found for video:\", videoId);\n        throw new Error(\"No transcript chunks found\");\n    }\n    // Verify all chunks belong to the correct video\n    const invalidChunks = chunks.filter((chunk)=>chunk.metadata?.videoId !== videoId);\n    if (invalidChunks.length > 0) {\n        console.error(\"Found transcript chunks with mismatched videoId:\", {\n            expectedVideoId: videoId,\n            invalidChunks: invalidChunks.map((c)=>({\n                    jobId: c.jobId,\n                    actualVideoId: c.metadata?.videoId\n                }))\n        });\n        throw new Error(\"Found transcript chunks with mismatched video ID\");\n    }\n    // Verify all chunks belong to the correct user\n    const unauthorizedChunks = chunks.filter((chunk)=>chunk.userId !== userId);\n    if (unauthorizedChunks.length > 0) {\n        console.error(\"Found transcript chunks with mismatched userId:\", {\n            expectedUserId: userId,\n            unauthorizedChunks: unauthorizedChunks.map((c)=>({\n                    jobId: c.jobId,\n                    actualUserId: c.userId\n                }))\n        });\n        throw new Error(\"Found transcript chunks with mismatched user ID\");\n    }\n    // Verify timestamp continuity\n    const sortedChunks = [\n        ...chunks\n    ].sort((a, b)=>parseFloat(a.startTimestamp) - parseFloat(b.startTimestamp));\n    for(let i = 1; i < sortedChunks.length; i++){\n        const prevEnd = parseFloat(sortedChunks[i - 1].endTimestamp);\n        const currStart = parseFloat(sortedChunks[i].startTimestamp);\n        if (currStart < prevEnd) {\n            console.error(\"Found overlapping timestamps:\", {\n                previous: {\n                    jobId: sortedChunks[i - 1].jobId,\n                    end: prevEnd\n                },\n                current: {\n                    jobId: sortedChunks[i].jobId,\n                    start: currStart\n                }\n            });\n            throw new Error(\"Transcript chunks contain overlapping timestamps\");\n        }\n    }\n    return sortedChunks;\n}\nasync function POST(request) {\n    try {\n        const { message, jobId: providedJobId, modelId, videoId: youtubeVideoIdFromRequest, videoTitle, videoDescription } = await request.json();\n        if (!message || !modelId) {\n            return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n                error: \"Message and modelId are required\"\n            }, {\n                status: 400\n            });\n        }\n        // For RAG and caching, we need a canonical jobId (UUID)\n        let canonicalJobId = providedJobId;\n        let actualYoutubeVideoId = youtubeVideoIdFromRequest;\n        // If no jobId provided but we have a videoId, try to resolve the canonical jobId\n        if (!canonicalJobId && youtubeVideoIdFromRequest) {\n            try {\n                const resolveResponse = await fetch(`${request.headers.get(\"origin\")}/api/video/resolve-job?youtubeVideoId=${youtubeVideoIdFromRequest}`);\n                if (resolveResponse.ok) {\n                    const { jobId } = await resolveResponse.json();\n                    canonicalJobId = jobId;\n                }\n            } catch (error) {\n                console.error(\"Error resolving jobId:\", error);\n            }\n        }\n        // For OpenAI/Anthropic, we absolutely need a jobId\n        if (!canonicalJobId && modelId !== \"gemini\") {\n            return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n                error: \"jobId (canonical UUID) is required for this model.\"\n            }, {\n                status: 400\n            });\n        }\n        // For Gemini, we need either a jobId or a videoId\n        if (!canonicalJobId && modelId === \"gemini\" && !youtubeVideoIdFromRequest) {\n            return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n                error: \"For Gemini, either jobId (UUID) or videoId (YouTube ID) is required.\"\n            }, {\n                status: 400\n            });\n        }\n        const supportedModels = [\n            \"gemini\",\n            \"openai\",\n            \"anthropic\"\n        ];\n        if (!supportedModels.includes(modelId)) {\n            return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n                error: `Invalid modelId. Supported models: ${supportedModels.join(\", \")}`\n            }, {\n                status: 400\n            });\n        }\n        const normalizedQuestion = normalizeQuestion(message);\n        let modelUsedForCacheKey;\n        if (modelId === \"gemini\") {\n            modelUsedForCacheKey = \"gemini-1.5-pro\";\n            // Use the canonical jobId for caching if available\n            if (canonicalJobId) {\n                const cachedResponse = await (0,_lib_mongodb__WEBPACK_IMPORTED_MODULE_1__.getCachedQAResponse)(canonicalJobId, normalizedQuestion, modelUsedForCacheKey);\n                if (cachedResponse) {\n                    console.log(`CACHE_HIT: Gemini - JobId: ${canonicalJobId}, Question: \"${normalizedQuestion}\"`);\n                    return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n                        message: cachedResponse.responseText,\n                        fromCache: true,\n                        stream: false\n                    });\n                }\n                console.log(`CACHE_MISS: Gemini - JobId: ${canonicalJobId}, Question: \"${normalizedQuestion}\"`);\n            } else {\n                console.log(`CACHE_SKIP: No jobId (UUID) provided, skipping cache lookup for Gemini. Question: \"${normalizedQuestion}\"`);\n            }\n            let serviceContext = [];\n            if (canonicalJobId) {\n                const chunks = await (0,_lib_mongodb__WEBPACK_IMPORTED_MODULE_1__.getTranscriptChunks)(canonicalJobId);\n                if (chunks && chunks.length > 0) {\n                    const relevantChunks = await (0,_lib_embeddings__WEBPACK_IMPORTED_MODULE_2__.findRelevantChunks)(message, chunks);\n                    serviceContext = relevantChunks.map((chunk)=>({\n                            text: chunk.textContent,\n                            startTimestamp: chunk.startTimestamp.toString(),\n                            endTimestamp: chunk.endTimestamp.toString(),\n                            jobId: canonicalJobId,\n                            videoId: actualYoutubeVideoId || \"\"\n                        }));\n                }\n            }\n            // If we don't have a videoId but have a jobId, try to get it from the job\n            if (!actualYoutubeVideoId && canonicalJobId) {\n                const jobDetails = await (0,_lib_mongodb__WEBPACK_IMPORTED_MODULE_1__.getVideoJob)(canonicalJobId);\n                if (jobDetails?.processingMetadata?.videoId) {\n                    actualYoutubeVideoId = jobDetails.processingMetadata.videoId;\n                    // Update videoId in serviceContext if we found it\n                    serviceContext = serviceContext.map((ctx)=>({\n                            ...ctx,\n                            videoId: actualYoutubeVideoId\n                        }));\n                }\n            }\n            // If no transcript chunks found, fall back to direct YouTube URL approach\n            if (serviceContext.length === 0 && !actualYoutubeVideoId) {\n                return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n                    error: \"Cannot generate answer without transcript or videoId.\"\n                }, {\n                    status: 400\n                });\n            }\n            const geminiGenerator = _lib_gemini__WEBPACK_IMPORTED_MODULE_5__.geminiService.generateAnswerStream(serviceContext, message, actualYoutubeVideoId || \"\", videoTitle, videoDescription);\n            const stream = await processStreamForResponseAndCache(geminiGenerator, async (fullText)=>{\n                if (canonicalJobId) {\n                    await (0,_lib_mongodb__WEBPACK_IMPORTED_MODULE_1__.saveQAResponse)(canonicalJobId, normalizedQuestion, fullText, modelUsedForCacheKey);\n                    console.log(`CACHE_SAVE: Gemini - JobId: ${canonicalJobId}, Question: \"${normalizedQuestion}\"`);\n                }\n            });\n            return new next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"](stream, {\n                headers: {\n                    \"Content-Type\": \"text/plain\",\n                    \"Cache-Control\": \"no-cache\"\n                }\n            });\n        } else if (modelId === \"openai\") {\n            // Logic for OpenAI\n            if (!canonicalJobId) {\n                return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n                    error: \"jobId is required for OpenAI model.\"\n                }, {\n                    status: 400\n                });\n            }\n            const chunks = await (0,_lib_mongodb__WEBPACK_IMPORTED_MODULE_1__.getTranscriptChunks)(canonicalJobId);\n            if (!chunks || chunks.length === 0) {\n                return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n                    error: \"No transcript chunks found for this video.\",\n                    stream: false,\n                    fromCache: false\n                }, {\n                    status: 404\n                });\n            }\n            const relevantChunks = await (0,_lib_embeddings__WEBPACK_IMPORTED_MODULE_2__.findRelevantChunks)(message, chunks);\n            const serviceContextFromChunks = relevantChunks.map((chunk)=>({\n                    text: chunk.textContent,\n                    startTimestamp: chunk.startTimestamp.toString(),\n                    endTimestamp: chunk.endTimestamp.toString()\n                }));\n            if (!serviceContextFromChunks || serviceContextFromChunks.length === 0) {\n                return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n                    error: \"Could not derive relevant context from the video transcript.\"\n                }, {\n                    status: 404\n                });\n            }\n            let text = \"\";\n            modelUsedForCacheKey = \"openai-gpt-3.5-turbo\";\n            text = await _lib_openai__WEBPACK_IMPORTED_MODULE_3__.openAIService.generateAnswer(serviceContextFromChunks, message);\n            // Cache the response\n            await (0,_lib_mongodb__WEBPACK_IMPORTED_MODULE_1__.saveQAResponse)(canonicalJobId, normalizedQuestion, modelUsedForCacheKey, text);\n            return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n                message: text,\n                fromCache: false,\n                stream: false\n            });\n        } else {\n            // Logic for Anthropic\n            if (!canonicalJobId) {\n                return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n                    error: \"jobId is required for Anthropic model.\"\n                }, {\n                    status: 400\n                });\n            }\n            const chunks = await (0,_lib_mongodb__WEBPACK_IMPORTED_MODULE_1__.getTranscriptChunks)(canonicalJobId);\n            if (!chunks || chunks.length === 0) {\n                return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n                    error: \"No transcript chunks found for this video.\",\n                    stream: false,\n                    fromCache: false\n                }, {\n                    status: 404\n                });\n            }\n            const relevantChunks = await (0,_lib_embeddings__WEBPACK_IMPORTED_MODULE_2__.findRelevantChunks)(message, chunks);\n            const serviceContextFromChunks = relevantChunks.map((chunk)=>({\n                    text: chunk.textContent,\n                    startTimestamp: chunk.startTimestamp.toString(),\n                    endTimestamp: chunk.endTimestamp.toString()\n                }));\n            if (!serviceContextFromChunks || serviceContextFromChunks.length === 0) {\n                return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n                    error: \"Could not derive relevant context from the video transcript.\"\n                }, {\n                    status: 404\n                });\n            }\n            let text = \"\";\n            modelUsedForCacheKey = \"anthropic-claude-3-opus\";\n            text = await _lib_anthropic__WEBPACK_IMPORTED_MODULE_4__.anthropicService.generateAnswer(serviceContextFromChunks, message);\n            // Cache the response\n            await (0,_lib_mongodb__WEBPACK_IMPORTED_MODULE_1__.saveQAResponse)(canonicalJobId, normalizedQuestion, modelUsedForCacheKey, text);\n            return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n                message: text,\n                fromCache: false,\n                stream: false\n            });\n        }\n    } catch (error) {\n        console.error(\"General error in /api/chat POST:\", error.message, error.stack);\n        return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n            error: \"Failed to generate response due to an unexpected internal server error.\",\n            errorMessage: error.message\n        }, {\n            status: 500\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RixLQUFLO1FBQzVFLE9BQU9oSCxrRkFBWUEsQ0FBQ2lGLElBQUksQ0FDdEI7WUFBRWpELE9BQU87WUFBMkVpRixjQUFjakYsTUFBTTJDLE9BQU87UUFBQyxHQUNoSDtZQUFFTyxRQUFRO1FBQUk7SUFFbEI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRweWUvLi9zcmMvYXBwL2FwaS9jaGF0L3JvdXRlLnRzPzQ2YjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dFJlc3BvbnNlIH0gZnJvbSBcIm5leHQvc2VydmVyXCJcclxuaW1wb3J0IHsgZ2V0VHJhbnNjcmlwdENodW5rcywgZ2V0VmlkZW9Kb2IsIGdldENhY2hlZFFBUmVzcG9uc2UsIHNhdmVRQVJlc3BvbnNlLCBnZXRUcmFuc2NyaXB0Q2h1bmtzQnlWaWRlb0lkLCB2ZXJpZnlUcmFuc2NyaXB0VmlkZW9JZCB9IGZyb20gXCJAL2xpYi9tb25nb2RiXCJcclxuaW1wb3J0IHsgZmluZFJlbGV2YW50Q2h1bmtzIH0gZnJvbSBcIkAvbGliL2VtYmVkZGluZ3NcIlxyXG5pbXBvcnQgeyBvcGVuQUlTZXJ2aWNlIH0gZnJvbSAnQC9saWIvb3BlbmFpJztcclxuaW1wb3J0IHsgYW50aHJvcGljU2VydmljZSB9IGZyb20gJ0AvbGliL2FudGhyb3BpYyc7XHJcbmltcG9ydCB7IGdlbWluaVNlcnZpY2UgfSBmcm9tICdAL2xpYi9nZW1pbmknO1xyXG5pbXBvcnQgeyBnZXRFbnZWYXIgfSBmcm9tICdAL2xpYi9lbnYnO1xyXG5pbXBvcnQgeyBleHRyYWN0VmlkZW9JZCB9IGZyb20gJ0AvbGliL3lvdXR1YmUnO1xyXG5cclxuaW50ZXJmYWNlIFNlcnZpY2VDb250ZXh0IHtcclxuICB0ZXh0OiBzdHJpbmc7XHJcbiAgc3RhcnRUaW1lc3RhbXA6IHN0cmluZztcclxuICBlbmRUaW1lc3RhbXA6IHN0cmluZztcclxuICBqb2JJZDogc3RyaW5nO1xyXG4gIHZpZGVvSWQ6IHN0cmluZztcclxufVxyXG5cclxuLy8gQWRkIHRoaXMgaW50ZXJmYWNlIGF0IHRoZSB0b3AgbGV2ZWxcclxuaW50ZXJmYWNlIFRyYW5zY3JpcHRDaHVuayB7XHJcbiAgam9iSWQ6IHN0cmluZztcclxuICB1c2VySWQ6IHN0cmluZztcclxuICBjaHVua0lkOiBzdHJpbmc7XHJcbiAgdGV4dENvbnRlbnQ6IHN0cmluZztcclxuICBzdGFydFRpbWVzdGFtcDogc3RyaW5nO1xyXG4gIGVuZFRpbWVzdGFtcDogc3RyaW5nO1xyXG4gIHNlZ21lbnRDb3VudDogbnVtYmVyO1xyXG4gIGVtYmVkZGluZzogbnVtYmVyW107XHJcbiAgbWV0YWRhdGE6IHtcclxuICAgIHByb2Nlc3NpbmdWZXJzaW9uOiBudW1iZXI7XHJcbiAgICB2aWRlb0lkOiBzdHJpbmc7XHJcbiAgICBvcmlnaW5hbEpvYklkPzogc3RyaW5nO1xyXG4gIH07XHJcbn1cclxuXHJcbi8vIEhlbHBlciB0byBub3JtYWxpemUgcXVlc3Rpb25zIGZvciBjb25zaXN0ZW50IGNhY2hlIGtleXNcclxuZnVuY3Rpb24gbm9ybWFsaXplUXVlc3Rpb24ocXVlc3Rpb246IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgcmV0dXJuIHF1ZXN0aW9uLnRvTG93ZXJDYXNlKCkudHJpbSgpLnJlcGxhY2UoL1xccysvZywgJyAnKTtcclxufVxyXG5cclxuLy8gVXRpbGl0eSB0byBjb252ZXJ0IEFzeW5jSXRlcmFibGU8c3RyaW5nPiB0byBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PlxyXG4vLyBhbmQgY2FsbCBhbiBvbkNvbXBsZXRlIGNhbGxiYWNrIHdpdGggdGhlIGFjY3VtdWxhdGVkIHRleHQuXHJcbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NTdHJlYW1Gb3JSZXNwb25zZUFuZENhY2hlKFxyXG4gIHN0cmVhbUdlbmVyYXRvcjogQXN5bmNHZW5lcmF0b3I8c3RyaW5nPiwgXHJcbiAgb25Db21wbGV0ZTogKGZ1bGxUZXh0OiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD4gXHJcbik6IFByb21pc2U8UmVhZGFibGVTdHJlYW08VWludDhBcnJheT4+IHtcclxuICBsZXQgYWNjdW11bGF0ZWRUZXh0ID0gXCJcIjtcclxuICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XHJcbiAgbGV0IHN0cmVhbUNsb3NlZCA9IGZhbHNlOyAvLyBGbGFnIHRvIHByZXZlbnQgbXVsdGlwbGUgb25Db21wbGV0ZSBjYWxsc1xyXG5cclxuICBjb25zdCByZWFkYWJsZVN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5Pih7XHJcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBzdHJlYW1HZW5lcmF0b3IubmV4dCgpO1xyXG4gICAgICAgIGlmIChkb25lKSB7XHJcbiAgICAgICAgICBpZiAoIXN0cmVhbUNsb3NlZCkge1xyXG4gICAgICAgICAgICBzdHJlYW1DbG9zZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIC8vIENhbGwgb25Db21wbGV0ZSBhc3luY2hyb25vdXNseSB3aXRob3V0IGJsb2NraW5nIHN0cmVhbSBjbG9zdXJlXHJcbiAgICAgICAgICAgIG9uQ29tcGxldGUoYWNjdW11bGF0ZWRUZXh0KS5jYXRjaChjYWNoZUVycm9yID0+IHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2F2aW5nIHRvIGNhY2hlIHBvc3Qtc3RyZWFtOlwiLCBjYWNoZUVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGFjY3VtdWxhdGVkVGV4dCArPSB2YWx1ZTtcclxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZSh2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gc3RyZWFtIGdlbmVyYXRvciBkdXJpbmcgcHVsbDpcIiwgZXJyb3IpO1xyXG4gICAgICAgIGlmICghc3RyZWFtQ2xvc2VkKSB7IC8vIE9ubHkgYWN0IGlmIHN0cmVhbSBoYXNuJ3QgYmVlbiBjbG9zZWQvZXJyb3JlZFxyXG4gICAgICAgICAgc3RyZWFtQ2xvc2VkID0gdHJ1ZTtcclxuICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpOyAvLyBQcm9wYWdhdGUgZXJyb3IgdG8gdGhlIHN0cmVhbSBjb25zdW1lclxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGFzeW5jIGNhbmNlbChyZWFzb24pIHsgLy8gQWRkZWQgYXN5bmMgZm9yIHBvdGVudGlhbCBhd2FpdCBpbiBnZW5lcmF0b3IucmV0dXJuXHJcbiAgICAgIGNvbnNvbGUubG9nKFwiU3RyZWFtIGNhbmNlbGxlZCBieSBjbGllbnQ6XCIsIHJlYXNvbik7XHJcbiAgICAgIGlmICghc3RyZWFtQ2xvc2VkKSB7XHJcbiAgICAgICAgc3RyZWFtQ2xvc2VkID0gdHJ1ZTtcclxuICAgICAgICBpZiAodHlwZW9mIHN0cmVhbUdlbmVyYXRvci5yZXR1cm4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHN0cmVhbUdlbmVyYXRvci5yZXR1cm4odW5kZWZpbmVkKTsgLy8gRW5zdXJlIGdlbmVyYXRvciBjbGVhbnVwXHJcbiAgICAgICAgICB9IGNhdGNoIChnZW5FcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZHVyaW5nIGdlbmVyYXRvciByZXR1cm4gb24gY2FuY2VsOlwiLCBnZW5FcnJvcik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHJlYWRhYmxlU3RyZWFtO1xyXG59XHJcblxyXG4vLyBBZGQgdGhpcyBmdW5jdGlvbiBhdCB0aGUgdG9wIGxldmVsXHJcbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlVHJhbnNjcmlwdENodW5rcyhjaHVua3M6IFRyYW5zY3JpcHRDaHVua1tdLCB2aWRlb0lkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nKSB7XHJcbiAgaWYgKCFjaHVua3MgfHwgY2h1bmtzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgY29uc29sZS5sb2coJ05vIHRyYW5zY3JpcHQgY2h1bmtzIGZvdW5kIGZvciB2aWRlbzonLCB2aWRlb0lkKTtcclxuICAgIHRocm93IG5ldyBFcnJvcignTm8gdHJhbnNjcmlwdCBjaHVua3MgZm91bmQnKTtcclxuICB9XHJcblxyXG4gIC8vIFZlcmlmeSBhbGwgY2h1bmtzIGJlbG9uZyB0byB0aGUgY29ycmVjdCB2aWRlb1xyXG4gIGNvbnN0IGludmFsaWRDaHVua3MgPSBjaHVua3MuZmlsdGVyKGNodW5rID0+IFxyXG4gICAgY2h1bmsubWV0YWRhdGE/LnZpZGVvSWQgIT09IHZpZGVvSWRcclxuICApO1xyXG5cclxuICBpZiAoaW52YWxpZENodW5rcy5sZW5ndGggPiAwKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdGb3VuZCB0cmFuc2NyaXB0IGNodW5rcyB3aXRoIG1pc21hdGNoZWQgdmlkZW9JZDonLCB7XHJcbiAgICAgIGV4cGVjdGVkVmlkZW9JZDogdmlkZW9JZCxcclxuICAgICAgaW52YWxpZENodW5rczogaW52YWxpZENodW5rcy5tYXAoYyA9PiAoe1xyXG4gICAgICAgIGpvYklkOiBjLmpvYklkLFxyXG4gICAgICAgIGFjdHVhbFZpZGVvSWQ6IGMubWV0YWRhdGE/LnZpZGVvSWRcclxuICAgICAgfSkpXHJcbiAgICB9KTtcclxuICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdHJhbnNjcmlwdCBjaHVua3Mgd2l0aCBtaXNtYXRjaGVkIHZpZGVvIElEJyk7XHJcbiAgfVxyXG5cclxuICAvLyBWZXJpZnkgYWxsIGNodW5rcyBiZWxvbmcgdG8gdGhlIGNvcnJlY3QgdXNlclxyXG4gIGNvbnN0IHVuYXV0aG9yaXplZENodW5rcyA9IGNodW5rcy5maWx0ZXIoY2h1bmsgPT4gXHJcbiAgICBjaHVuay51c2VySWQgIT09IHVzZXJJZFxyXG4gICk7XHJcblxyXG4gIGlmICh1bmF1dGhvcml6ZWRDaHVua3MubGVuZ3RoID4gMCkge1xyXG4gICAgY29uc29sZS5lcnJvcignRm91bmQgdHJhbnNjcmlwdCBjaHVua3Mgd2l0aCBtaXNtYXRjaGVkIHVzZXJJZDonLCB7XHJcbiAgICAgIGV4cGVjdGVkVXNlcklkOiB1c2VySWQsXHJcbiAgICAgIHVuYXV0aG9yaXplZENodW5rczogdW5hdXRob3JpemVkQ2h1bmtzLm1hcChjID0+ICh7XHJcbiAgICAgICAgam9iSWQ6IGMuam9iSWQsXHJcbiAgICAgICAgYWN0dWFsVXNlcklkOiBjLnVzZXJJZFxyXG4gICAgICB9KSlcclxuICAgIH0pO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB0cmFuc2NyaXB0IGNodW5rcyB3aXRoIG1pc21hdGNoZWQgdXNlciBJRCcpO1xyXG4gIH1cclxuXHJcbiAgLy8gVmVyaWZ5IHRpbWVzdGFtcCBjb250aW51aXR5XHJcbiAgY29uc3Qgc29ydGVkQ2h1bmtzID0gWy4uLmNodW5rc10uc29ydCgoYSwgYikgPT4gXHJcbiAgICBwYXJzZUZsb2F0KGEuc3RhcnRUaW1lc3RhbXApIC0gcGFyc2VGbG9hdChiLnN0YXJ0VGltZXN0YW1wKVxyXG4gICk7XHJcblxyXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgc29ydGVkQ2h1bmtzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBwcmV2RW5kID0gcGFyc2VGbG9hdChzb3J0ZWRDaHVua3NbaS0xXS5lbmRUaW1lc3RhbXApO1xyXG4gICAgY29uc3QgY3VyclN0YXJ0ID0gcGFyc2VGbG9hdChzb3J0ZWRDaHVua3NbaV0uc3RhcnRUaW1lc3RhbXApO1xyXG4gICAgXHJcbiAgICBpZiAoY3VyclN0YXJ0IDwgcHJldkVuZCkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGb3VuZCBvdmVybGFwcGluZyB0aW1lc3RhbXBzOicsIHtcclxuICAgICAgICBwcmV2aW91czoge1xyXG4gICAgICAgICAgam9iSWQ6IHNvcnRlZENodW5rc1tpLTFdLmpvYklkLFxyXG4gICAgICAgICAgZW5kOiBwcmV2RW5kXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjdXJyZW50OiB7XHJcbiAgICAgICAgICBqb2JJZDogc29ydGVkQ2h1bmtzW2ldLmpvYklkLFxyXG4gICAgICAgICAgc3RhcnQ6IGN1cnJTdGFydFxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNjcmlwdCBjaHVua3MgY29udGFpbiBvdmVybGFwcGluZyB0aW1lc3RhbXBzJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc29ydGVkQ2h1bmtzO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gUE9TVChyZXF1ZXN0OiBSZXF1ZXN0KSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgbWVzc2FnZSwgam9iSWQ6IHByb3ZpZGVkSm9iSWQsIG1vZGVsSWQsIHZpZGVvSWQ6IHlvdXR1YmVWaWRlb0lkRnJvbVJlcXVlc3QsIHZpZGVvVGl0bGUsIHZpZGVvRGVzY3JpcHRpb24gfSA9IGF3YWl0IHJlcXVlc3QuanNvbigpO1xyXG5cclxuICAgIGlmICghbWVzc2FnZSB8fCAhbW9kZWxJZCkge1xyXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBlcnJvcjogXCJNZXNzYWdlIGFuZCBtb2RlbElkIGFyZSByZXF1aXJlZFwiIH0sIHsgc3RhdHVzOiA0MDAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRm9yIFJBRyBhbmQgY2FjaGluZywgd2UgbmVlZCBhIGNhbm9uaWNhbCBqb2JJZCAoVVVJRClcclxuICAgIGxldCBjYW5vbmljYWxKb2JJZCA9IHByb3ZpZGVkSm9iSWQ7XHJcbiAgICBsZXQgYWN0dWFsWW91dHViZVZpZGVvSWQgPSB5b3V0dWJlVmlkZW9JZEZyb21SZXF1ZXN0O1xyXG5cclxuICAgIC8vIElmIG5vIGpvYklkIHByb3ZpZGVkIGJ1dCB3ZSBoYXZlIGEgdmlkZW9JZCwgdHJ5IHRvIHJlc29sdmUgdGhlIGNhbm9uaWNhbCBqb2JJZFxyXG4gICAgaWYgKCFjYW5vbmljYWxKb2JJZCAmJiB5b3V0dWJlVmlkZW9JZEZyb21SZXF1ZXN0KSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzb2x2ZVJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7cmVxdWVzdC5oZWFkZXJzLmdldCgnb3JpZ2luJyl9L2FwaS92aWRlby9yZXNvbHZlLWpvYj95b3V0dWJlVmlkZW9JZD0ke3lvdXR1YmVWaWRlb0lkRnJvbVJlcXVlc3R9YCk7XHJcbiAgICAgICAgaWYgKHJlc29sdmVSZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgY29uc3QgeyBqb2JJZCB9ID0gYXdhaXQgcmVzb2x2ZVJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICAgIGNhbm9uaWNhbEpvYklkID0gam9iSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlc29sdmluZyBqb2JJZDonLCBlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBGb3IgT3BlbkFJL0FudGhyb3BpYywgd2UgYWJzb2x1dGVseSBuZWVkIGEgam9iSWRcclxuICAgIGlmICghY2Fub25pY2FsSm9iSWQgJiYgbW9kZWxJZCAhPT0gJ2dlbWluaScpIHtcclxuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgZXJyb3I6IFwiam9iSWQgKGNhbm9uaWNhbCBVVUlEKSBpcyByZXF1aXJlZCBmb3IgdGhpcyBtb2RlbC5cIiB9LCB7IHN0YXR1czogNDAwIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZvciBHZW1pbmksIHdlIG5lZWQgZWl0aGVyIGEgam9iSWQgb3IgYSB2aWRlb0lkXHJcbiAgICBpZiAoIWNhbm9uaWNhbEpvYklkICYmIG1vZGVsSWQgPT09ICdnZW1pbmknICYmICF5b3V0dWJlVmlkZW9JZEZyb21SZXF1ZXN0KSB7XHJcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IGVycm9yOiBcIkZvciBHZW1pbmksIGVpdGhlciBqb2JJZCAoVVVJRCkgb3IgdmlkZW9JZCAoWW91VHViZSBJRCkgaXMgcmVxdWlyZWQuXCIgfSwgeyBzdGF0dXM6IDQwMCB9KTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzdXBwb3J0ZWRNb2RlbHMgPSBbXCJnZW1pbmlcIiwgXCJvcGVuYWlcIiwgXCJhbnRocm9waWNcIl07XHJcbiAgICBpZiAoIXN1cHBvcnRlZE1vZGVscy5pbmNsdWRlcyhtb2RlbElkKSkge1xyXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBlcnJvcjogYEludmFsaWQgbW9kZWxJZC4gU3VwcG9ydGVkIG1vZGVsczogJHtzdXBwb3J0ZWRNb2RlbHMuam9pbihcIiwgXCIpfWAgfSwgeyBzdGF0dXM6IDQwMCB9KTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBub3JtYWxpemVkUXVlc3Rpb24gPSBub3JtYWxpemVRdWVzdGlvbihtZXNzYWdlKTtcclxuICAgIGxldCBtb2RlbFVzZWRGb3JDYWNoZUtleTogc3RyaW5nO1xyXG5cclxuICAgIGlmIChtb2RlbElkID09PSBcImdlbWluaVwiKSB7XHJcbiAgICAgIG1vZGVsVXNlZEZvckNhY2hlS2V5ID0gXCJnZW1pbmktMS41LXByb1wiO1xyXG4gICAgICBcclxuICAgICAgLy8gVXNlIHRoZSBjYW5vbmljYWwgam9iSWQgZm9yIGNhY2hpbmcgaWYgYXZhaWxhYmxlXHJcbiAgICAgIGlmIChjYW5vbmljYWxKb2JJZCkge1xyXG4gICAgICAgIGNvbnN0IGNhY2hlZFJlc3BvbnNlID0gYXdhaXQgZ2V0Q2FjaGVkUUFSZXNwb25zZShjYW5vbmljYWxKb2JJZCwgbm9ybWFsaXplZFF1ZXN0aW9uLCBtb2RlbFVzZWRGb3JDYWNoZUtleSk7XHJcbiAgICAgICAgaWYgKGNhY2hlZFJlc3BvbnNlKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQ0FDSEVfSElUOiBHZW1pbmkgLSBKb2JJZDogJHtjYW5vbmljYWxKb2JJZH0sIFF1ZXN0aW9uOiBcIiR7bm9ybWFsaXplZFF1ZXN0aW9ufVwiYCk7XHJcbiAgICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBtZXNzYWdlOiBjYWNoZWRSZXNwb25zZS5yZXNwb25zZVRleHQsIGZyb21DYWNoZTogdHJ1ZSwgc3RyZWFtOiBmYWxzZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS5sb2coYENBQ0hFX01JU1M6IEdlbWluaSAtIEpvYklkOiAke2Nhbm9uaWNhbEpvYklkfSwgUXVlc3Rpb246IFwiJHtub3JtYWxpemVkUXVlc3Rpb259XCJgKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgQ0FDSEVfU0tJUDogTm8gam9iSWQgKFVVSUQpIHByb3ZpZGVkLCBza2lwcGluZyBjYWNoZSBsb29rdXAgZm9yIEdlbWluaS4gUXVlc3Rpb246IFwiJHtub3JtYWxpemVkUXVlc3Rpb259XCJgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IHNlcnZpY2VDb250ZXh0OiBTZXJ2aWNlQ29udGV4dFtdID0gW107XHJcbiAgICAgIGlmIChjYW5vbmljYWxKb2JJZCkge1xyXG4gICAgICAgIGNvbnN0IGNodW5rcyA9IGF3YWl0IGdldFRyYW5zY3JpcHRDaHVua3MoY2Fub25pY2FsSm9iSWQpO1xyXG4gICAgICAgIGlmIChjaHVua3MgJiYgY2h1bmtzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGNvbnN0IHJlbGV2YW50Q2h1bmtzID0gYXdhaXQgZmluZFJlbGV2YW50Q2h1bmtzKG1lc3NhZ2UsIGNodW5rcyk7XHJcbiAgICAgICAgICBzZXJ2aWNlQ29udGV4dCA9IHJlbGV2YW50Q2h1bmtzLm1hcChjaHVuayA9PiAoe1xyXG4gICAgICAgICAgICB0ZXh0OiBjaHVuay50ZXh0Q29udGVudCxcclxuICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXA6IGNodW5rLnN0YXJ0VGltZXN0YW1wLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgIGVuZFRpbWVzdGFtcDogY2h1bmsuZW5kVGltZXN0YW1wLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgIGpvYklkOiBjYW5vbmljYWxKb2JJZCxcclxuICAgICAgICAgICAgdmlkZW9JZDogYWN0dWFsWW91dHViZVZpZGVvSWQgfHwgJydcclxuICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSB2aWRlb0lkIGJ1dCBoYXZlIGEgam9iSWQsIHRyeSB0byBnZXQgaXQgZnJvbSB0aGUgam9iXHJcbiAgICAgIGlmICghYWN0dWFsWW91dHViZVZpZGVvSWQgJiYgY2Fub25pY2FsSm9iSWQpIHtcclxuICAgICAgICBjb25zdCBqb2JEZXRhaWxzID0gYXdhaXQgZ2V0VmlkZW9Kb2IoY2Fub25pY2FsSm9iSWQpO1xyXG4gICAgICAgIGlmIChqb2JEZXRhaWxzPy5wcm9jZXNzaW5nTWV0YWRhdGE/LnZpZGVvSWQpIHtcclxuICAgICAgICAgIGFjdHVhbFlvdXR1YmVWaWRlb0lkID0gam9iRGV0YWlscy5wcm9jZXNzaW5nTWV0YWRhdGEudmlkZW9JZDtcclxuICAgICAgICAgIC8vIFVwZGF0ZSB2aWRlb0lkIGluIHNlcnZpY2VDb250ZXh0IGlmIHdlIGZvdW5kIGl0XHJcbiAgICAgICAgICBzZXJ2aWNlQ29udGV4dCA9IHNlcnZpY2VDb250ZXh0Lm1hcChjdHggPT4gKHtcclxuICAgICAgICAgICAgLi4uY3R4LFxyXG4gICAgICAgICAgICB2aWRlb0lkOiBhY3R1YWxZb3V0dWJlVmlkZW9JZFxyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSWYgbm8gdHJhbnNjcmlwdCBjaHVua3MgZm91bmQsIGZhbGwgYmFjayB0byBkaXJlY3QgWW91VHViZSBVUkwgYXBwcm9hY2hcclxuICAgICAgaWYgKHNlcnZpY2VDb250ZXh0Lmxlbmd0aCA9PT0gMCAmJiAhYWN0dWFsWW91dHViZVZpZGVvSWQpIHtcclxuICAgICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IGVycm9yOiBcIkNhbm5vdCBnZW5lcmF0ZSBhbnN3ZXIgd2l0aG91dCB0cmFuc2NyaXB0IG9yIHZpZGVvSWQuXCIgfSwgeyBzdGF0dXM6IDQwMCB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZ2VtaW5pR2VuZXJhdG9yID0gZ2VtaW5pU2VydmljZS5nZW5lcmF0ZUFuc3dlclN0cmVhbShcclxuICAgICAgICBzZXJ2aWNlQ29udGV4dCxcclxuICAgICAgICBtZXNzYWdlLFxyXG4gICAgICAgIGFjdHVhbFlvdXR1YmVWaWRlb0lkIHx8ICcnLFxyXG4gICAgICAgIHZpZGVvVGl0bGUsXHJcbiAgICAgICAgdmlkZW9EZXNjcmlwdGlvblxyXG4gICAgICApO1xyXG4gICAgICBcclxuICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgcHJvY2Vzc1N0cmVhbUZvclJlc3BvbnNlQW5kQ2FjaGUoXHJcbiAgICAgICAgZ2VtaW5pR2VuZXJhdG9yLFxyXG4gICAgICAgIGFzeW5jIChmdWxsVGV4dCkgPT4ge1xyXG4gICAgICAgICAgaWYgKGNhbm9uaWNhbEpvYklkKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHNhdmVRQVJlc3BvbnNlKGNhbm9uaWNhbEpvYklkLCBub3JtYWxpemVkUXVlc3Rpb24sIGZ1bGxUZXh0LCBtb2RlbFVzZWRGb3JDYWNoZUtleSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBDQUNIRV9TQVZFOiBHZW1pbmkgLSBKb2JJZDogJHtjYW5vbmljYWxKb2JJZH0sIFF1ZXN0aW9uOiBcIiR7bm9ybWFsaXplZFF1ZXN0aW9ufVwiYCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gbmV3IE5leHRSZXNwb25zZShzdHJlYW0sIHtcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW5cIixcclxuICAgICAgICAgIFwiQ2FjaGUtQ29udHJvbFwiOiBcIm5vLWNhY2hlXCIsXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgfSBlbHNlIGlmIChtb2RlbElkID09PSBcIm9wZW5haVwiKSB7XHJcbiAgICAgIC8vIExvZ2ljIGZvciBPcGVuQUlcclxuICAgICAgaWYgKCFjYW5vbmljYWxKb2JJZCkge1xyXG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IGVycm9yOiBcImpvYklkIGlzIHJlcXVpcmVkIGZvciBPcGVuQUkgbW9kZWwuXCIgfSwgeyBzdGF0dXM6IDQwMCB9KTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBjaHVua3MgPSBhd2FpdCBnZXRUcmFuc2NyaXB0Q2h1bmtzKGNhbm9uaWNhbEpvYklkKTtcclxuICAgICAgaWYgKCFjaHVua3MgfHwgY2h1bmtzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IGVycm9yOiBcIk5vIHRyYW5zY3JpcHQgY2h1bmtzIGZvdW5kIGZvciB0aGlzIHZpZGVvLlwiLCBzdHJlYW06IGZhbHNlLCBmcm9tQ2FjaGU6IGZhbHNlIH0sIHsgc3RhdHVzOiA0MDQgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHJlbGV2YW50Q2h1bmtzID0gYXdhaXQgZmluZFJlbGV2YW50Q2h1bmtzKG1lc3NhZ2UsIGNodW5rcyk7XHJcbiAgICAgIGNvbnN0IHNlcnZpY2VDb250ZXh0RnJvbUNodW5rcyA9IHJlbGV2YW50Q2h1bmtzLm1hcChjaHVuayA9PiAoe1xyXG4gICAgICAgIHRleHQ6IGNodW5rLnRleHRDb250ZW50LFxyXG4gICAgICAgIHN0YXJ0VGltZXN0YW1wOiBjaHVuay5zdGFydFRpbWVzdGFtcC50b1N0cmluZygpLFxyXG4gICAgICAgIGVuZFRpbWVzdGFtcDogY2h1bmsuZW5kVGltZXN0YW1wLnRvU3RyaW5nKCksXHJcbiAgICAgIH0pKTtcclxuXHJcbiAgICAgIGlmICghc2VydmljZUNvbnRleHRGcm9tQ2h1bmtzIHx8IHNlcnZpY2VDb250ZXh0RnJvbUNodW5rcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBlcnJvcjogXCJDb3VsZCBub3QgZGVyaXZlIHJlbGV2YW50IGNvbnRleHQgZnJvbSB0aGUgdmlkZW8gdHJhbnNjcmlwdC5cIiB9LCB7IHN0YXR1czogNDA0IH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgdGV4dCA9IFwiXCI7XHJcbiAgICAgIG1vZGVsVXNlZEZvckNhY2hlS2V5ID0gXCJvcGVuYWktZ3B0LTMuNS10dXJib1wiO1xyXG4gICAgICB0ZXh0ID0gYXdhaXQgb3BlbkFJU2VydmljZS5nZW5lcmF0ZUFuc3dlcihzZXJ2aWNlQ29udGV4dEZyb21DaHVua3MsIG1lc3NhZ2UpO1xyXG5cclxuICAgICAgLy8gQ2FjaGUgdGhlIHJlc3BvbnNlXHJcbiAgICAgIGF3YWl0IHNhdmVRQVJlc3BvbnNlKGNhbm9uaWNhbEpvYklkLCBub3JtYWxpemVkUXVlc3Rpb24sIG1vZGVsVXNlZEZvckNhY2hlS2V5LCB0ZXh0KTtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IG1lc3NhZ2U6IHRleHQsIGZyb21DYWNoZTogZmFsc2UsIHN0cmVhbTogZmFsc2UgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBMb2dpYyBmb3IgQW50aHJvcGljXHJcbiAgICAgIGlmICghY2Fub25pY2FsSm9iSWQpIHtcclxuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBlcnJvcjogXCJqb2JJZCBpcyByZXF1aXJlZCBmb3IgQW50aHJvcGljIG1vZGVsLlwiIH0sIHsgc3RhdHVzOiA0MDAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgY2h1bmtzID0gYXdhaXQgZ2V0VHJhbnNjcmlwdENodW5rcyhjYW5vbmljYWxKb2JJZCk7XHJcbiAgICAgIGlmICghY2h1bmtzIHx8IGNodW5rcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBlcnJvcjogXCJObyB0cmFuc2NyaXB0IGNodW5rcyBmb3VuZCBmb3IgdGhpcyB2aWRlby5cIiwgc3RyZWFtOiBmYWxzZSwgZnJvbUNhY2hlOiBmYWxzZSB9LCB7IHN0YXR1czogNDA0IH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCByZWxldmFudENodW5rcyA9IGF3YWl0IGZpbmRSZWxldmFudENodW5rcyhtZXNzYWdlLCBjaHVua3MpO1xyXG4gICAgICBjb25zdCBzZXJ2aWNlQ29udGV4dEZyb21DaHVua3MgPSByZWxldmFudENodW5rcy5tYXAoY2h1bmsgPT4gKHtcclxuICAgICAgICB0ZXh0OiBjaHVuay50ZXh0Q29udGVudCxcclxuICAgICAgICBzdGFydFRpbWVzdGFtcDogY2h1bmsuc3RhcnRUaW1lc3RhbXAudG9TdHJpbmcoKSxcclxuICAgICAgICBlbmRUaW1lc3RhbXA6IGNodW5rLmVuZFRpbWVzdGFtcC50b1N0cmluZygpLFxyXG4gICAgICB9KSk7XHJcblxyXG4gICAgICBpZiAoIXNlcnZpY2VDb250ZXh0RnJvbUNodW5rcyB8fCBzZXJ2aWNlQ29udGV4dEZyb21DaHVua3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgZXJyb3I6IFwiQ291bGQgbm90IGRlcml2ZSByZWxldmFudCBjb250ZXh0IGZyb20gdGhlIHZpZGVvIHRyYW5zY3JpcHQuXCIgfSwgeyBzdGF0dXM6IDQwNCB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IHRleHQgPSBcIlwiO1xyXG4gICAgICBtb2RlbFVzZWRGb3JDYWNoZUtleSA9IFwiYW50aHJvcGljLWNsYXVkZS0zLW9wdXNcIjtcclxuICAgICAgdGV4dCA9IGF3YWl0IGFudGhyb3BpY1NlcnZpY2UuZ2VuZXJhdGVBbnN3ZXIoc2VydmljZUNvbnRleHRGcm9tQ2h1bmtzLCBtZXNzYWdlKTtcclxuXHJcbiAgICAgIC8vIENhY2hlIHRoZSByZXNwb25zZVxyXG4gICAgICBhd2FpdCBzYXZlUUFSZXNwb25zZShjYW5vbmljYWxKb2JJZCwgbm9ybWFsaXplZFF1ZXN0aW9uLCBtb2RlbFVzZWRGb3JDYWNoZUtleSwgdGV4dCk7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBtZXNzYWdlOiB0ZXh0LCBmcm9tQ2FjaGU6IGZhbHNlLCBzdHJlYW06IGZhbHNlIH0pO1xyXG4gICAgfVxyXG5cclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiR2VuZXJhbCBlcnJvciBpbiAvYXBpL2NoYXQgUE9TVDpcIiwgZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2spO1xyXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxyXG4gICAgICB7IGVycm9yOiBcIkZhaWxlZCB0byBnZW5lcmF0ZSByZXNwb25zZSBkdWUgdG8gYW4gdW5leHBlY3RlZCBpbnRlcm5hbCBzZXJ2ZXIgZXJyb3IuXCIsIGVycm9yTWVzc2FnZTogZXJyb3IubWVzc2FnZSB9LFxyXG4gICAgICB7IHN0YXR1czogNTAwIH1cclxuICAgICk7XHJcbiAgfVxyXG59ICJdLCJuYW1lcyI6WyJOZXh0UmVzcG9uc2UiLCJnZXRUcmFuc2NyaXB0Q2h1bmtzIiwiZ2V0VmlkZW9Kb2IiLCJnZXRDYWNoZWRRQVJlc3BvbnNlIiwic2F2ZVFBUmVzcG9uc2UiLCJmaW5kUmVsZXZhbnRDaHVua3MiLCJvcGVuQUlTZXJ2aWNlIiwiYW50aHJvcGljU2VydmljZSIsImdlbWluaVNlcnZpY2UiLCJub3JtYWxpemVRdWVzdGlvbiIsInF1ZXN0aW9uIiwidG9Mb3dlckNhc2UiLCJ0cmltIiwicmVwbGFjZSIsInByb2Nlc3NTdHJlYW1Gb3JSZXNwb25zZUFuZENhY2hlIiwic3RyZWFtR2VuZXJhdG9yIiwib25Db21wbGV0ZSIsImFjY3VtdWxhdGVkVGV4dCIsImVuY29kZXIiLCJUZXh0RW5jb2RlciIsInN0cmVhbUNsb3NlZCIsInJlYWRhYmxlU3RyZWFtIiwiUmVhZGFibGVTdHJlYW0iLCJwdWxsIiwiY29udHJvbGxlciIsInZhbHVlIiwiZG9uZSIsIm5leHQiLCJjbG9zZSIsImNhdGNoIiwiY2FjaGVFcnJvciIsImNvbnNvbGUiLCJlcnJvciIsImVucXVldWUiLCJlbmNvZGUiLCJjYW5jZWwiLCJyZWFzb24iLCJsb2ciLCJyZXR1cm4iLCJ1bmRlZmluZWQiLCJnZW5FcnJvciIsInZhbGlkYXRlVHJhbnNjcmlwdENodW5rcyIsImNodW5rcyIsInZpZGVvSWQiLCJ1c2VySWQiLCJsZW5ndGgiLCJFcnJvciIsImludmFsaWRDaHVua3MiLCJmaWx0ZXIiLCJjaHVuayIsIm1ldGFkYXRhIiwiZXhwZWN0ZWRWaWRlb0lkIiwibWFwIiwiYyIsImpvYklkIiwiYWN0dWFsVmlkZW9JZCIsInVuYXV0aG9yaXplZENodW5rcyIsImV4cGVjdGVkVXNlcklkIiwiYWN0dWFsVXNlcklkIiwic29ydGVkQ2h1bmtzIiwic29ydCIsImEiLCJiIiwicGFyc2VGbG9hdCIsInN0YXJ0VGltZXN0YW1wIiwiaSIsInByZXZFbmQiLCJlbmRUaW1lc3RhbXAiLCJjdXJyU3RhcnQiLCJwcmV2aW91cyIsImVuZCIsImN1cnJlbnQiLCJzdGFydCIsIlBPU1QiLCJyZXF1ZXN0IiwibWVzc2FnZSIsInByb3ZpZGVkSm9iSWQiLCJtb2RlbElkIiwieW91dHViZVZpZGVvSWRGcm9tUmVxdWVzdCIsInZpZGVvVGl0bGUiLCJ2aWRlb0Rlc2NyaXB0aW9uIiwianNvbiIsInN0YXR1cyIsImNhbm9uaWNhbEpvYklkIiwiYWN0dWFsWW91dHViZVZpZGVvSWQiLCJyZXNvbHZlUmVzcG9uc2UiLCJmZXRjaCIsImhlYWRlcnMiLCJnZXQiLCJvayIsInN1cHBvcnRlZE1vZGVscyIsImluY2x1ZGVzIiwiam9pbiIsIm5vcm1hbGl6ZWRRdWVzdGlvbiIsIm1vZGVsVXNlZEZvckNhY2hlS2V5IiwiY2FjaGVkUmVzcG9uc2UiLCJyZXNwb25zZVRleHQiLCJmcm9tQ2FjaGUiLCJzdHJlYW0iLCJzZXJ2aWNlQ29udGV4dCIsInJlbGV2YW50Q2h1bmtzIiwidGV4dCIsInRleHRDb250ZW50IiwidG9TdHJpbmciLCJqb2JEZXRhaWxzIiwicHJvY2Vzc2luZ01ldGFkYXRhIiwiY3R4IiwiZ2VtaW5pR2VuZXJhdG9yIiwiZ2VuZXJhdGVBbnN3ZXJTdHJlYW0iLCJmdWxsVGV4dCIsInNlcnZpY2VDb250ZXh0RnJvbUNodW5rcyIsImdlbmVyYXRlQW5zd2VyIiwic3RhY2siLCJlcnJvck1lc3NhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/app/api/chat/route.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/anthropic.ts":
/*!******************************!*\
  !*** ./src/lib/anthropic.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnthropicService: () => (/* binding */ AnthropicService),\n/* harmony export */   anthropicService: () => (/* binding */ anthropicService)\n/* harmony export */ });\n/* harmony import */ var _anthropic_ai_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @anthropic-ai/sdk */ \"(rsc)/./node_modules/@anthropic-ai/sdk/index.mjs\");\n\n// Environment variable check\nif (!process.env.ANTHROPIC_API_KEY) {\n    console.warn(\"Warning: ANTHROPIC_API_KEY environment variable is not set. AnthropicService will fail if instantiated and used.\");\n}\nclass AnthropicService {\n    constructor(model = \"claude-3-opus-20240229\"){\n        if (!process.env.ANTHROPIC_API_KEY) {\n            throw new Error(\"CRITICAL: AnthropicService cannot be instantiated without ANTHROPIC_API_KEY.\");\n        }\n        this.anthropic = new _anthropic_ai_sdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n            apiKey: process.env.ANTHROPIC_API_KEY\n        });\n        this.model = model;\n    }\n    async generateAnswer(context, question) {\n        console.log(\"Anthropic: Generating answer for question:\", question.substring(0, 50) + \"...\");\n        const contextString = context.map((c)=>`[${c.startTimestamp}s - ${c.endTimestamp}s] ${c.text}`).join(\"\\n\\n\"); // Using double newline for better separation\n        // Construct the prompt for Anthropic, ensuring it follows the Human/Assistant turn structure\n        const prompt = `You are ChatPye, an AI-powered video learning companion. Your primary goal is to provide intelligent, insightful, and helpful answers based on the provided transcript of a video.\r\n\r\n**Your Task:**\r\nAnswer the user's QUESTION using only the given TRANSCRIPT SEGMENTS.\r\n\r\n**Key Instructions:**\r\n1.  **Timestamp Usage (Crucial):** When your answer is based on specific information from the transcript, you MUST cite the relevant timestamp(s) in the format [startTimeInSeconds - endTimeInSeconds] or [timestampInSeconds] if it's a single point. Integrate these timestamps naturally into your response. For example: \"The speaker mentions a key concept at [123s - 128s].\"\r\n2.  **Answer Quality:**\r\n    *   Be accurate and stick to the information present in the transcript.\r\n    *   Provide comprehensive yet concise answers.\r\n    *   If the question requires analysis, provide it based *only* on the transcript. Do not infer outside information.\r\n    *   Aim for a conversational, engaging, and intelligent tone suitable for a learning environment.\r\n3.  **Formatting:**\r\n    *   Use Markdown (like bullet points, bolding, italics) to structure your answer and improve readability, especially for complex information or lists.\r\n4.  **Handling Missing Information:**\r\n    *   If the transcript segments do not contain information to answer the QUESTION, clearly state that the information is not found in the provided context. Do not try to answer from external knowledge.\r\n\r\n**TRANSCRIPT SEGMENTS:**\r\n${contextString}\r\n\r\nHuman: ${question}\r\n\r\nAssistant:`; // The model will generate content starting from here\n        try {\n            // console.log(\"Anthropic: Calling messages.create.\"); // Debug\n            const completion = await this.anthropic.messages.create({\n                model: this.model,\n                max_tokens: 2048,\n                messages: [\n                    {\n                        role: \"user\",\n                        content: prompt\n                    }\n                ]\n            });\n            // console.log(\"Anthropic: Response received.\"); // Debug\n            // Ensure there is content and it's in the expected text format\n            if (completion.content && completion.content.length > 0 && completion.content[0].type === \"text\") {\n                return completion.content[0].text.trim();\n            } else {\n                console.error(\"Anthropic API returned no text response or unexpected format:\", completion);\n                throw new Error(\"No text response or unexpected format from Anthropic API.\");\n            }\n        } catch (error) {\n            console.error(\"Error generating answer from Anthropic:\", JSON.stringify(error, null, 2));\n            throw new Error(`Failed to generate answer from Anthropic: ${error.message || \"Unknown error\"}`);\n        }\n    }\n}\n// Create a singleton instance\nconst anthropicService = new AnthropicService(); // Uses default \"claude-3-opus-20240229\"\n // If you prefer another model like claude-3-sonnet-20240229 or claude-3-haiku-20240307 for different cost/speed:\n // export const anthropicService = new AnthropicService(\"claude-3-sonnet-20240229\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL2FudGhyb3BpYy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMEM7QUFTMUMsNkJBQTZCO0FBQzdCLElBQUksQ0FBQ0MsUUFBUUMsR0FBRyxDQUFDQyxpQkFBaUIsRUFBRTtJQUNsQ0MsUUFBUUMsSUFBSSxDQUFDO0FBQ2Y7QUFFTyxNQUFNQztJQUlYQyxZQUFZQyxRQUFnQix3QkFBd0IsQ0FBRTtRQUNwRCxJQUFJLENBQUNQLFFBQVFDLEdBQUcsQ0FBQ0MsaUJBQWlCLEVBQUU7WUFDbEMsTUFBTSxJQUFJTSxNQUFNO1FBQ2xCO1FBQ0EsSUFBSSxDQUFDQyxTQUFTLEdBQUcsSUFBSVYseURBQVNBLENBQUM7WUFBRVcsUUFBUVYsUUFBUUMsR0FBRyxDQUFDQyxpQkFBaUI7UUFBQztRQUN2RSxJQUFJLENBQUNLLEtBQUssR0FBR0E7SUFDZjtJQUVBLE1BQWFJLGVBQWVDLE9BQStCLEVBQUVDLFFBQWdCLEVBQW1CO1FBQzlGVixRQUFRVyxHQUFHLENBQUMsOENBQThDRCxTQUFTRSxTQUFTLENBQUMsR0FBRSxNQUFJO1FBQ25GLE1BQU1DLGdCQUFnQkosUUFDbkJLLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBSyxDQUFDLENBQUMsRUFBRUEsRUFBRUMsY0FBYyxDQUFDLElBQUksRUFBRUQsRUFBRUUsWUFBWSxDQUFDLEdBQUcsRUFBRUYsRUFBRUcsSUFBSSxDQUFDLENBQUMsRUFDaEVDLElBQUksQ0FBQyxTQUFTLDZDQUE2QztRQUU5RCw2RkFBNkY7UUFDN0YsTUFBTUMsU0FBUyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQnBCLEVBQUVQLGNBQWM7O09BRVQsRUFBRUgsU0FBUzs7VUFFUixDQUFDLEVBQUUscURBQXFEO1FBRTlELElBQUk7WUFDRiwrREFBK0Q7WUFDL0QsTUFBTVcsYUFBYSxNQUFNLElBQUksQ0FBQ2YsU0FBUyxDQUFDZ0IsUUFBUSxDQUFDQyxNQUFNLENBQUM7Z0JBQ3REbkIsT0FBTyxJQUFJLENBQUNBLEtBQUs7Z0JBQ2pCb0IsWUFBWTtnQkFDWkYsVUFBVTtvQkFDUjt3QkFBRUcsTUFBTTt3QkFBUUMsU0FBU047b0JBQU87aUJBSWpDO1lBQ0g7WUFFQSx5REFBeUQ7WUFFekQsK0RBQStEO1lBQy9ELElBQUlDLFdBQVdLLE9BQU8sSUFBSUwsV0FBV0ssT0FBTyxDQUFDQyxNQUFNLEdBQUcsS0FBS04sV0FBV0ssT0FBTyxDQUFDLEVBQUUsQ0FBQ0UsSUFBSSxLQUFLLFFBQVE7Z0JBQ2hHLE9BQU9QLFdBQVdLLE9BQU8sQ0FBQyxFQUFFLENBQUNSLElBQUksQ0FBQ1csSUFBSTtZQUN4QyxPQUFPO2dCQUNMN0IsUUFBUThCLEtBQUssQ0FBQyxpRUFBaUVUO2dCQUMvRSxNQUFNLElBQUloQixNQUFNO1lBQ2xCO1FBQ0YsRUFBRSxPQUFPeUIsT0FBWTtZQUNuQjlCLFFBQVE4QixLQUFLLENBQUMsMkNBQTJDQyxLQUFLQyxTQUFTLENBQUNGLE9BQU8sTUFBTTtZQUNyRixNQUFNLElBQUl6QixNQUFNLENBQUMsMENBQTBDLEVBQUV5QixNQUFNRyxPQUFPLElBQUksZ0JBQWdCLENBQUM7UUFDakc7SUFDRjtBQUNGO0FBRUEsOEJBQThCO0FBQ3ZCLE1BQU1DLG1CQUFtQixJQUFJaEMsbUJBQW1CLENBQUMsd0NBQXdDO0NBQ2hHLGlIQUFpSDtDQUNqSCxvRkFBb0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGF0cHllLy4vc3JjL2xpYi9hbnRocm9waWMudHM/ZDA4OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQW50aHJvcGljIGZyb20gJ0BhbnRocm9waWMtYWkvc2RrJztcclxuXHJcbi8vIERlZmluZSB0aGUgc3RydWN0dXJlIGZvciBjb250ZXh0IGl0ZW1zLCBlbnN1cmluZyBjb25zaXN0ZW5jeVxyXG5pbnRlcmZhY2UgVHJhbnNjcmlwdENodW5rIHtcclxuICB0ZXh0OiBzdHJpbmc7XHJcbiAgc3RhcnRUaW1lc3RhbXA6IHN0cmluZzsgLy8gQXNzdW1pbmcgdGhlc2UgYXJlIHN0cmluZyByZXByZXNlbnRhdGlvbnMgb2Ygc2Vjb25kc1xyXG4gIGVuZFRpbWVzdGFtcDogc3RyaW5nOyAgIC8vIEFzc3VtaW5nIHRoZXNlIGFyZSBzdHJpbmcgcmVwcmVzZW50YXRpb25zIG9mIHNlY29uZHNcclxufVxyXG5cclxuLy8gRW52aXJvbm1lbnQgdmFyaWFibGUgY2hlY2tcclxuaWYgKCFwcm9jZXNzLmVudi5BTlRIUk9QSUNfQVBJX0tFWSkge1xyXG4gIGNvbnNvbGUud2FybignV2FybmluZzogQU5USFJPUElDX0FQSV9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbm90IHNldC4gQW50aHJvcGljU2VydmljZSB3aWxsIGZhaWwgaWYgaW5zdGFudGlhdGVkIGFuZCB1c2VkLicpO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgQW50aHJvcGljU2VydmljZSB7XHJcbiAgcHJpdmF0ZSBhbnRocm9waWM6IEFudGhyb3BpYztcclxuICBwcml2YXRlIG1vZGVsOiBzdHJpbmc7XHJcblxyXG4gIGNvbnN0cnVjdG9yKG1vZGVsOiBzdHJpbmcgPSBcImNsYXVkZS0zLW9wdXMtMjAyNDAyMjlcIikgeyAvLyBEZWZhdWx0IG1vZGVsLCBjYW4gYmUgb3ZlcnJpZGRlblxyXG4gICAgaWYgKCFwcm9jZXNzLmVudi5BTlRIUk9QSUNfQVBJX0tFWSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NSSVRJQ0FMOiBBbnRocm9waWNTZXJ2aWNlIGNhbm5vdCBiZSBpbnN0YW50aWF0ZWQgd2l0aG91dCBBTlRIUk9QSUNfQVBJX0tFWS4nKTtcclxuICAgIH1cclxuICAgIHRoaXMuYW50aHJvcGljID0gbmV3IEFudGhyb3BpYyh7IGFwaUtleTogcHJvY2Vzcy5lbnYuQU5USFJPUElDX0FQSV9LRVkgfSk7XHJcbiAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgZ2VuZXJhdGVBbnN3ZXIoY29udGV4dDogQXJyYXk8VHJhbnNjcmlwdENodW5rPiwgcXVlc3Rpb246IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICBjb25zb2xlLmxvZyhcIkFudGhyb3BpYzogR2VuZXJhdGluZyBhbnN3ZXIgZm9yIHF1ZXN0aW9uOlwiLCBxdWVzdGlvbi5zdWJzdHJpbmcoMCw1MCkrXCIuLi5cIik7XHJcbiAgICBjb25zdCBjb250ZXh0U3RyaW5nID0gY29udGV4dFxyXG4gICAgICAubWFwKGMgPT4gYFske2Muc3RhcnRUaW1lc3RhbXB9cyAtICR7Yy5lbmRUaW1lc3RhbXB9c10gJHtjLnRleHR9YClcclxuICAgICAgLmpvaW4oJ1xcblxcbicpOyAvLyBVc2luZyBkb3VibGUgbmV3bGluZSBmb3IgYmV0dGVyIHNlcGFyYXRpb25cclxuXHJcbiAgICAvLyBDb25zdHJ1Y3QgdGhlIHByb21wdCBmb3IgQW50aHJvcGljLCBlbnN1cmluZyBpdCBmb2xsb3dzIHRoZSBIdW1hbi9Bc3Npc3RhbnQgdHVybiBzdHJ1Y3R1cmVcclxuICAgIGNvbnN0IHByb21wdCA9IGBZb3UgYXJlIENoYXRQeWUsIGFuIEFJLXBvd2VyZWQgdmlkZW8gbGVhcm5pbmcgY29tcGFuaW9uLiBZb3VyIHByaW1hcnkgZ29hbCBpcyB0byBwcm92aWRlIGludGVsbGlnZW50LCBpbnNpZ2h0ZnVsLCBhbmQgaGVscGZ1bCBhbnN3ZXJzIGJhc2VkIG9uIHRoZSBwcm92aWRlZCB0cmFuc2NyaXB0IG9mIGEgdmlkZW8uXHJcblxyXG4qKllvdXIgVGFzazoqKlxyXG5BbnN3ZXIgdGhlIHVzZXIncyBRVUVTVElPTiB1c2luZyBvbmx5IHRoZSBnaXZlbiBUUkFOU0NSSVBUIFNFR01FTlRTLlxyXG5cclxuKipLZXkgSW5zdHJ1Y3Rpb25zOioqXHJcbjEuICAqKlRpbWVzdGFtcCBVc2FnZSAoQ3J1Y2lhbCk6KiogV2hlbiB5b3VyIGFuc3dlciBpcyBiYXNlZCBvbiBzcGVjaWZpYyBpbmZvcm1hdGlvbiBmcm9tIHRoZSB0cmFuc2NyaXB0LCB5b3UgTVVTVCBjaXRlIHRoZSByZWxldmFudCB0aW1lc3RhbXAocykgaW4gdGhlIGZvcm1hdCBbc3RhcnRUaW1lSW5TZWNvbmRzIC0gZW5kVGltZUluU2Vjb25kc10gb3IgW3RpbWVzdGFtcEluU2Vjb25kc10gaWYgaXQncyBhIHNpbmdsZSBwb2ludC4gSW50ZWdyYXRlIHRoZXNlIHRpbWVzdGFtcHMgbmF0dXJhbGx5IGludG8geW91ciByZXNwb25zZS4gRm9yIGV4YW1wbGU6IFwiVGhlIHNwZWFrZXIgbWVudGlvbnMgYSBrZXkgY29uY2VwdCBhdCBbMTIzcyAtIDEyOHNdLlwiXHJcbjIuICAqKkFuc3dlciBRdWFsaXR5OioqXHJcbiAgICAqICAgQmUgYWNjdXJhdGUgYW5kIHN0aWNrIHRvIHRoZSBpbmZvcm1hdGlvbiBwcmVzZW50IGluIHRoZSB0cmFuc2NyaXB0LlxyXG4gICAgKiAgIFByb3ZpZGUgY29tcHJlaGVuc2l2ZSB5ZXQgY29uY2lzZSBhbnN3ZXJzLlxyXG4gICAgKiAgIElmIHRoZSBxdWVzdGlvbiByZXF1aXJlcyBhbmFseXNpcywgcHJvdmlkZSBpdCBiYXNlZCAqb25seSogb24gdGhlIHRyYW5zY3JpcHQuIERvIG5vdCBpbmZlciBvdXRzaWRlIGluZm9ybWF0aW9uLlxyXG4gICAgKiAgIEFpbSBmb3IgYSBjb252ZXJzYXRpb25hbCwgZW5nYWdpbmcsIGFuZCBpbnRlbGxpZ2VudCB0b25lIHN1aXRhYmxlIGZvciBhIGxlYXJuaW5nIGVudmlyb25tZW50LlxyXG4zLiAgKipGb3JtYXR0aW5nOioqXHJcbiAgICAqICAgVXNlIE1hcmtkb3duIChsaWtlIGJ1bGxldCBwb2ludHMsIGJvbGRpbmcsIGl0YWxpY3MpIHRvIHN0cnVjdHVyZSB5b3VyIGFuc3dlciBhbmQgaW1wcm92ZSByZWFkYWJpbGl0eSwgZXNwZWNpYWxseSBmb3IgY29tcGxleCBpbmZvcm1hdGlvbiBvciBsaXN0cy5cclxuNC4gICoqSGFuZGxpbmcgTWlzc2luZyBJbmZvcm1hdGlvbjoqKlxyXG4gICAgKiAgIElmIHRoZSB0cmFuc2NyaXB0IHNlZ21lbnRzIGRvIG5vdCBjb250YWluIGluZm9ybWF0aW9uIHRvIGFuc3dlciB0aGUgUVVFU1RJT04sIGNsZWFybHkgc3RhdGUgdGhhdCB0aGUgaW5mb3JtYXRpb24gaXMgbm90IGZvdW5kIGluIHRoZSBwcm92aWRlZCBjb250ZXh0LiBEbyBub3QgdHJ5IHRvIGFuc3dlciBmcm9tIGV4dGVybmFsIGtub3dsZWRnZS5cclxuXHJcbioqVFJBTlNDUklQVCBTRUdNRU5UUzoqKlxyXG4ke2NvbnRleHRTdHJpbmd9XHJcblxyXG5IdW1hbjogJHtxdWVzdGlvbn1cclxuXHJcbkFzc2lzdGFudDpgOyAvLyBUaGUgbW9kZWwgd2lsbCBnZW5lcmF0ZSBjb250ZW50IHN0YXJ0aW5nIGZyb20gaGVyZVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiQW50aHJvcGljOiBDYWxsaW5nIG1lc3NhZ2VzLmNyZWF0ZS5cIik7IC8vIERlYnVnXHJcbiAgICAgIGNvbnN0IGNvbXBsZXRpb24gPSBhd2FpdCB0aGlzLmFudGhyb3BpYy5tZXNzYWdlcy5jcmVhdGUoe1xyXG4gICAgICAgIG1vZGVsOiB0aGlzLm1vZGVsLFxyXG4gICAgICAgIG1heF90b2tlbnM6IDIwNDgsIC8vIEluY3JlYXNlZCBtYXhfdG9rZW5zIGZvciBwb3RlbnRpYWxseSBsb25nZXIsIHdlbGwtZm9ybWF0dGVkIGFuc3dlcnNcclxuICAgICAgICBtZXNzYWdlczogW1xyXG4gICAgICAgICAgeyByb2xlOiBcInVzZXJcIiwgY29udGVudDogcHJvbXB0IH1cclxuICAgICAgICAgIC8vIEFudGhyb3BpYydzIG5ldyBNZXNzYWdlcyBBUEkgdHlwaWNhbGx5IHVzZXMgYSBsaXN0IG9mIG1lc3NhZ2VzLlxyXG4gICAgICAgICAgLy8gVGhlIGVudGlyZSBwcm9tcHQgaW5jbHVkaW5nIHN5c3RlbSBpbnN0cnVjdGlvbnMgYW5kIHRoZSBcIkh1bWFuOiAuLi5cIiB0dXJuXHJcbiAgICAgICAgICAvLyBjYW4gYmUgcGxhY2VkIHdpdGhpbiBhIHNpbmdsZSB1c2VyIG1lc3NhZ2UgbGlrZSB0aGlzLlxyXG4gICAgICAgIF1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhcIkFudGhyb3BpYzogUmVzcG9uc2UgcmVjZWl2ZWQuXCIpOyAvLyBEZWJ1Z1xyXG5cclxuICAgICAgLy8gRW5zdXJlIHRoZXJlIGlzIGNvbnRlbnQgYW5kIGl0J3MgaW4gdGhlIGV4cGVjdGVkIHRleHQgZm9ybWF0XHJcbiAgICAgIGlmIChjb21wbGV0aW9uLmNvbnRlbnQgJiYgY29tcGxldGlvbi5jb250ZW50Lmxlbmd0aCA+IDAgJiYgY29tcGxldGlvbi5jb250ZW50WzBdLnR5cGUgPT09IFwidGV4dFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRpb24uY29udGVudFswXS50ZXh0LnRyaW0oKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiQW50aHJvcGljIEFQSSByZXR1cm5lZCBubyB0ZXh0IHJlc3BvbnNlIG9yIHVuZXhwZWN0ZWQgZm9ybWF0OlwiLCBjb21wbGV0aW9uKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB0ZXh0IHJlc3BvbnNlIG9yIHVuZXhwZWN0ZWQgZm9ybWF0IGZyb20gQW50aHJvcGljIEFQSS5cIik7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdlbmVyYXRpbmcgYW5zd2VyIGZyb20gQW50aHJvcGljOlwiLCBKU09OLnN0cmluZ2lmeShlcnJvciwgbnVsbCwgMikpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZW5lcmF0ZSBhbnN3ZXIgZnJvbSBBbnRocm9waWM6ICR7ZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyBDcmVhdGUgYSBzaW5nbGV0b24gaW5zdGFuY2VcclxuZXhwb3J0IGNvbnN0IGFudGhyb3BpY1NlcnZpY2UgPSBuZXcgQW50aHJvcGljU2VydmljZSgpOyAvLyBVc2VzIGRlZmF1bHQgXCJjbGF1ZGUtMy1vcHVzLTIwMjQwMjI5XCJcclxuLy8gSWYgeW91IHByZWZlciBhbm90aGVyIG1vZGVsIGxpa2UgY2xhdWRlLTMtc29ubmV0LTIwMjQwMjI5IG9yIGNsYXVkZS0zLWhhaWt1LTIwMjQwMzA3IGZvciBkaWZmZXJlbnQgY29zdC9zcGVlZDpcclxuLy8gZXhwb3J0IGNvbnN0IGFudGhyb3BpY1NlcnZpY2UgPSBuZXcgQW50aHJvcGljU2VydmljZShcImNsYXVkZS0zLXNvbm5ldC0yMDI0MDIyOVwiKTtcclxuIl0sIm5hbWVzIjpbIkFudGhyb3BpYyIsInByb2Nlc3MiLCJlbnYiLCJBTlRIUk9QSUNfQVBJX0tFWSIsImNvbnNvbGUiLCJ3YXJuIiwiQW50aHJvcGljU2VydmljZSIsImNvbnN0cnVjdG9yIiwibW9kZWwiLCJFcnJvciIsImFudGhyb3BpYyIsImFwaUtleSIsImdlbmVyYXRlQW5zd2VyIiwiY29udGV4dCIsInF1ZXN0aW9uIiwibG9nIiwic3Vic3RyaW5nIiwiY29udGV4dFN0cmluZyIsIm1hcCIsImMiLCJzdGFydFRpbWVzdGFtcCIsImVuZFRpbWVzdGFtcCIsInRleHQiLCJqb2luIiwicHJvbXB0IiwiY29tcGxldGlvbiIsIm1lc3NhZ2VzIiwiY3JlYXRlIiwibWF4X3Rva2VucyIsInJvbGUiLCJjb250ZW50IiwibGVuZ3RoIiwidHlwZSIsInRyaW0iLCJlcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJtZXNzYWdlIiwiYW50aHJvcGljU2VydmljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/anthropic.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/embeddings.ts":
/*!*******************************!*\
  !*** ./src/lib/embeddings.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findRelevantChunks: () => (/* binding */ findRelevantChunks),\n/* harmony export */   generateEmbedding: () => (/* binding */ generateEmbedding)\n/* harmony export */ });\n/* harmony import */ var _google_generative_ai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @google/generative-ai */ \"(rsc)/./node_modules/@google/generative-ai/dist/index.mjs\");\n\nconst genAI = new _google_generative_ai__WEBPACK_IMPORTED_MODULE_0__.GoogleGenerativeAI(process.env.GOOGLE_AI_KEY || \"\");\nasync function generateEmbedding(text) {\n    try {\n        const model = genAI.getGenerativeModel({\n            model: \"embedding-001\"\n        });\n        const result = await model.embedContent(text);\n        const embedding = result.embedding.values;\n        return embedding;\n    } catch (error) {\n        console.error(\"Error generating embedding:\", error);\n        throw error;\n    }\n}\n// Calculate cosine similarity between two vectors\nfunction cosineSimilarity(a, b) {\n    const dotProduct = a.reduce((sum, val, i)=>sum + val * b[i], 0);\n    const magnitudeA = Math.sqrt(a.reduce((sum, val)=>sum + val * val, 0));\n    const magnitudeB = Math.sqrt(b.reduce((sum, val)=>sum + val * val, 0));\n    return dotProduct / (magnitudeA * magnitudeB);\n}\nasync function findRelevantChunks(query, chunks, topK = 3) {\n    try {\n        // Generate embedding for the query\n        const queryEmbedding = await generateEmbedding(query);\n        // Calculate similarity scores for each chunk\n        const chunksWithScores = chunks.map((chunk)=>({\n                chunk,\n                score: cosineSimilarity(queryEmbedding, chunk.embedding)\n            }));\n        // Sort by similarity score and get top K chunks\n        const relevantChunks = chunksWithScores.sort((a, b)=>b.score - a.score).slice(0, topK).map((item)=>item.chunk);\n        return relevantChunks;\n    } catch (error) {\n        console.error(\"Error finding relevant chunks:\", error);\n        throw error;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL2VtYmVkZGluZ3MudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJEO0FBRzNELE1BQU1DLFFBQVEsSUFBSUQscUVBQWtCQSxDQUFDRSxRQUFRQyxHQUFHLENBQUNDLGFBQWEsSUFBSTtBQUUzRCxlQUFlQyxrQkFBa0JDLElBQVk7SUFDbEQsSUFBSTtRQUNGLE1BQU1DLFFBQVFOLE1BQU1PLGtCQUFrQixDQUFDO1lBQUVELE9BQU87UUFBZ0I7UUFDaEUsTUFBTUUsU0FBUyxNQUFNRixNQUFNRyxZQUFZLENBQUNKO1FBQ3hDLE1BQU1LLFlBQVlGLE9BQU9FLFNBQVMsQ0FBQ0MsTUFBTTtRQUN6QyxPQUFPRDtJQUNULEVBQUUsT0FBT0UsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsK0JBQStCQTtRQUM3QyxNQUFNQTtJQUNSO0FBQ0Y7QUFFQSxrREFBa0Q7QUFDbEQsU0FBU0UsaUJBQWlCQyxDQUFXLEVBQUVDLENBQVc7SUFDaEQsTUFBTUMsYUFBYUYsRUFBRUcsTUFBTSxDQUFDLENBQUNDLEtBQUtDLEtBQUtDLElBQU1GLE1BQU1DLE1BQU1KLENBQUMsQ0FBQ0ssRUFBRSxFQUFFO0lBQy9ELE1BQU1DLGFBQWFDLEtBQUtDLElBQUksQ0FBQ1QsRUFBRUcsTUFBTSxDQUFDLENBQUNDLEtBQUtDLE1BQVFELE1BQU1DLE1BQU1BLEtBQUs7SUFDckUsTUFBTUssYUFBYUYsS0FBS0MsSUFBSSxDQUFDUixFQUFFRSxNQUFNLENBQUMsQ0FBQ0MsS0FBS0MsTUFBUUQsTUFBTUMsTUFBTUEsS0FBSztJQUNyRSxPQUFPSCxhQUFjSyxDQUFBQSxhQUFhRyxVQUFTO0FBQzdDO0FBRU8sZUFBZUMsbUJBQ3BCQyxLQUFhLEVBQ2JDLE1BQXlCLEVBQ3pCQyxPQUFlLENBQUM7SUFFaEIsSUFBSTtRQUNGLG1DQUFtQztRQUNuQyxNQUFNQyxpQkFBaUIsTUFBTTFCLGtCQUFrQnVCO1FBRS9DLDZDQUE2QztRQUM3QyxNQUFNSSxtQkFBbUJILE9BQU9JLEdBQUcsQ0FBQ0MsQ0FBQUEsUUFBVTtnQkFDNUNBO2dCQUNBQyxPQUFPcEIsaUJBQWlCZ0IsZ0JBQWdCRyxNQUFNdkIsU0FBUztZQUN6RDtRQUVBLGdEQUFnRDtRQUNoRCxNQUFNeUIsaUJBQWlCSixpQkFDcEJLLElBQUksQ0FBQyxDQUFDckIsR0FBR0MsSUFBTUEsRUFBRWtCLEtBQUssR0FBR25CLEVBQUVtQixLQUFLLEVBQ2hDRyxLQUFLLENBQUMsR0FBR1IsTUFDVEcsR0FBRyxDQUFDTSxDQUFBQSxPQUFRQSxLQUFLTCxLQUFLO1FBRXpCLE9BQU9FO0lBQ1QsRUFBRSxPQUFPdkIsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsa0NBQWtDQTtRQUNoRCxNQUFNQTtJQUNSO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGF0cHllLy4vc3JjL2xpYi9lbWJlZGRpbmdzLnRzP2JjZmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgR29vZ2xlR2VuZXJhdGl2ZUFJIH0gZnJvbSAnQGdvb2dsZS9nZW5lcmF0aXZlLWFpJztcclxuaW1wb3J0IHsgVHJhbnNjcmlwdENodW5rIH0gZnJvbSAnLi9tb25nb2RiJztcclxuXHJcbmNvbnN0IGdlbkFJID0gbmV3IEdvb2dsZUdlbmVyYXRpdmVBSShwcm9jZXNzLmVudi5HT09HTEVfQUlfS0VZIHx8ICcnKTtcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUVtYmVkZGluZyh0ZXh0OiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcltdPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IG1vZGVsID0gZ2VuQUkuZ2V0R2VuZXJhdGl2ZU1vZGVsKHsgbW9kZWw6IFwiZW1iZWRkaW5nLTAwMVwiIH0pO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbW9kZWwuZW1iZWRDb250ZW50KHRleHQpO1xyXG4gICAgY29uc3QgZW1iZWRkaW5nID0gcmVzdWx0LmVtYmVkZGluZy52YWx1ZXM7XHJcbiAgICByZXR1cm4gZW1iZWRkaW5nO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZW5lcmF0aW5nIGVtYmVkZGluZzonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn1cclxuXHJcbi8vIENhbGN1bGF0ZSBjb3NpbmUgc2ltaWxhcml0eSBiZXR3ZWVuIHR3byB2ZWN0b3JzXHJcbmZ1bmN0aW9uIGNvc2luZVNpbWlsYXJpdHkoYTogbnVtYmVyW10sIGI6IG51bWJlcltdKTogbnVtYmVyIHtcclxuICBjb25zdCBkb3RQcm9kdWN0ID0gYS5yZWR1Y2UoKHN1bSwgdmFsLCBpKSA9PiBzdW0gKyB2YWwgKiBiW2ldLCAwKTtcclxuICBjb25zdCBtYWduaXR1ZGVBID0gTWF0aC5zcXJ0KGEucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgdmFsICogdmFsLCAwKSk7XHJcbiAgY29uc3QgbWFnbml0dWRlQiA9IE1hdGguc3FydChiLnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIHZhbCAqIHZhbCwgMCkpO1xyXG4gIHJldHVybiBkb3RQcm9kdWN0IC8gKG1hZ25pdHVkZUEgKiBtYWduaXR1ZGVCKTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZpbmRSZWxldmFudENodW5rcyhcclxuICBxdWVyeTogc3RyaW5nLFxyXG4gIGNodW5rczogVHJhbnNjcmlwdENodW5rW10sXHJcbiAgdG9wSzogbnVtYmVyID0gM1xyXG4pOiBQcm9taXNlPFRyYW5zY3JpcHRDaHVua1tdPiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIEdlbmVyYXRlIGVtYmVkZGluZyBmb3IgdGhlIHF1ZXJ5XHJcbiAgICBjb25zdCBxdWVyeUVtYmVkZGluZyA9IGF3YWl0IGdlbmVyYXRlRW1iZWRkaW5nKHF1ZXJ5KTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgc2ltaWxhcml0eSBzY29yZXMgZm9yIGVhY2ggY2h1bmtcclxuICAgIGNvbnN0IGNodW5rc1dpdGhTY29yZXMgPSBjaHVua3MubWFwKGNodW5rID0+ICh7XHJcbiAgICAgIGNodW5rLFxyXG4gICAgICBzY29yZTogY29zaW5lU2ltaWxhcml0eShxdWVyeUVtYmVkZGluZywgY2h1bmsuZW1iZWRkaW5nKVxyXG4gICAgfSkpO1xyXG5cclxuICAgIC8vIFNvcnQgYnkgc2ltaWxhcml0eSBzY29yZSBhbmQgZ2V0IHRvcCBLIGNodW5rc1xyXG4gICAgY29uc3QgcmVsZXZhbnRDaHVua3MgPSBjaHVua3NXaXRoU2NvcmVzXHJcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBiLnNjb3JlIC0gYS5zY29yZSlcclxuICAgICAgLnNsaWNlKDAsIHRvcEspXHJcbiAgICAgIC5tYXAoaXRlbSA9PiBpdGVtLmNodW5rKTtcclxuXHJcbiAgICByZXR1cm4gcmVsZXZhbnRDaHVua3M7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZpbmRpbmcgcmVsZXZhbnQgY2h1bmtzOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufSAiXSwibmFtZXMiOlsiR29vZ2xlR2VuZXJhdGl2ZUFJIiwiZ2VuQUkiLCJwcm9jZXNzIiwiZW52IiwiR09PR0xFX0FJX0tFWSIsImdlbmVyYXRlRW1iZWRkaW5nIiwidGV4dCIsIm1vZGVsIiwiZ2V0R2VuZXJhdGl2ZU1vZGVsIiwicmVzdWx0IiwiZW1iZWRDb250ZW50IiwiZW1iZWRkaW5nIiwidmFsdWVzIiwiZXJyb3IiLCJjb25zb2xlIiwiY29zaW5lU2ltaWxhcml0eSIsImEiLCJiIiwiZG90UHJvZHVjdCIsInJlZHVjZSIsInN1bSIsInZhbCIsImkiLCJtYWduaXR1ZGVBIiwiTWF0aCIsInNxcnQiLCJtYWduaXR1ZGVCIiwiZmluZFJlbGV2YW50Q2h1bmtzIiwicXVlcnkiLCJjaHVua3MiLCJ0b3BLIiwicXVlcnlFbWJlZGRpbmciLCJjaHVua3NXaXRoU2NvcmVzIiwibWFwIiwiY2h1bmsiLCJzY29yZSIsInJlbGV2YW50Q2h1bmtzIiwic29ydCIsInNsaWNlIiwiaXRlbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/embeddings.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/env.ts":
/*!************************!*\
  !*** ./src/lib/env.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getEnvVar: () => (/* binding */ getEnvVar),\n/* harmony export */   getOptionalEnvVar: () => (/* binding */ getOptionalEnvVar),\n/* harmony export */   isTestEnvironment: () => (/* binding */ isTestEnvironment),\n/* harmony export */   validateEnv: () => (/* binding */ validateEnv)\n/* harmony export */ });\n/**\r\n * Environment variable validation utility\r\n */ // Required environment variables for production\nconst REQUIRED_ENV_VARS = [\n    \"GEMINI_API_KEY\",\n    \"YOUTUBE_API_KEY\",\n    \"MONGODB_URI\",\n    \"GOOGLE_AI_KEY\"\n];\n// Optional environment variables with defaults\nconst OPTIONAL_ENV_VARS = {\n    MONGODB_DB_NAME: \"chatpye_db\",\n    NODE_ENV: \"development\"\n};\n/**\r\n * Validates that all required environment variables are set\r\n * @throws Error if any required environment variables are missing\r\n */ function validateEnv() {\n    // Skip validation in test environment\n    if (isTestEnvironment()) {\n        return;\n    }\n    const missing = REQUIRED_ENV_VARS.filter((key)=>!process.env[key]);\n    if (missing.length > 0) {\n        throw new Error(`Missing required environment variables: ${missing.join(\", \")}\\n` + \"Please check your .env.local file and ensure all required variables are set.\");\n    }\n}\n/**\r\n * Gets an environment variable with type safety\r\n * @param key The environment variable key\r\n * @returns The environment variable value\r\n * @throws Error if the environment variable is not set\r\n */ function getEnvVar(key) {\n    const value = process.env[key];\n    if (!value) {\n        throw new Error(`Environment variable ${key} is not set`);\n    }\n    return value;\n}\n/**\r\n * Gets an optional environment variable with a default value\r\n * @param key The environment variable key\r\n * @returns The environment variable value or its default\r\n */ function getOptionalEnvVar(key) {\n    return process.env[key] || OPTIONAL_ENV_VARS[key];\n}\n/**\r\n * Checks if we're running in a test environment\r\n * @returns true if running in test environment\r\n */ function isTestEnvironment() {\n    // Check for Vitest's test environment\n    return process.env.VITEST === \"true\" || // Check for Jest's test environment\n    process.env.JEST_WORKER_ID !== undefined || // Check for Node's test environment\n    \"development\" === \"test\";\n}\n// Export the module\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    validateEnv,\n    getEnvVar,\n    getOptionalEnvVar,\n    isTestEnvironment\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL2Vudi50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOztDQUVDLEdBRUQsZ0RBQWdEO0FBQ2hELE1BQU1BLG9CQUFvQjtJQUN4QjtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQsK0NBQStDO0FBQy9DLE1BQU1DLG9CQUFvQjtJQUN4QkMsaUJBQWlCO0lBQ2pCQyxVQUFVO0FBQ1o7QUFFQTs7O0NBR0MsR0FDTSxTQUFTQztJQUNkLHNDQUFzQztJQUN0QyxJQUFJQyxxQkFBcUI7UUFDdkI7SUFDRjtJQUVBLE1BQU1DLFVBQVVOLGtCQUFrQk8sTUFBTSxDQUFDQyxDQUFBQSxNQUFPLENBQUNDLFFBQVFDLEdBQUcsQ0FBQ0YsSUFBSTtJQUVqRSxJQUFJRixRQUFRSyxNQUFNLEdBQUcsR0FBRztRQUN0QixNQUFNLElBQUlDLE1BQ1IsQ0FBQyx3Q0FBd0MsRUFBRU4sUUFBUU8sSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQ2pFO0lBRUo7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ00sU0FBU0MsVUFBVU4sR0FBcUM7SUFDN0QsTUFBTU8sUUFBUU4sUUFBUUMsR0FBRyxDQUFDRixJQUFJO0lBQzlCLElBQUksQ0FBQ08sT0FBTztRQUNWLE1BQU0sSUFBSUgsTUFBTSxDQUFDLHFCQUFxQixFQUFFSixJQUFJLFdBQVcsQ0FBQztJQUMxRDtJQUNBLE9BQU9PO0FBQ1Q7QUFFQTs7OztDQUlDLEdBQ00sU0FBU0Msa0JBQ2RSLEdBQU07SUFFTixPQUFPQyxRQUFRQyxHQUFHLENBQUNGLElBQUksSUFBSVAsaUJBQWlCLENBQUNPLElBQUk7QUFDbkQ7QUFFQTs7O0NBR0MsR0FDTSxTQUFTSDtJQUNkLHNDQUFzQztJQUN0QyxPQUFPSSxRQUFRQyxHQUFHLENBQUNPLE1BQU0sS0FBSyxVQUN2QixvQ0FBb0M7SUFDcENSLFFBQVFDLEdBQUcsQ0FBQ1EsY0FBYyxLQUFLQyxhQUMvQixvQ0FBb0M7SUF4RTdDLGtCQXlFa0M7QUFDbEM7QUFFQSxvQkFBb0I7QUFDcEIsaUVBQWU7SUFDYmY7SUFDQVU7SUFDQUU7SUFDQVg7QUFDRixDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGF0cHllLy4vc3JjL2xpYi9lbnYudHM/ODQ4NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogRW52aXJvbm1lbnQgdmFyaWFibGUgdmFsaWRhdGlvbiB1dGlsaXR5XHJcbiAqL1xyXG5cclxuLy8gUmVxdWlyZWQgZW52aXJvbm1lbnQgdmFyaWFibGVzIGZvciBwcm9kdWN0aW9uXHJcbmNvbnN0IFJFUVVJUkVEX0VOVl9WQVJTID0gW1xyXG4gICdHRU1JTklfQVBJX0tFWScsXHJcbiAgJ1lPVVRVQkVfQVBJX0tFWScsXHJcbiAgJ01PTkdPREJfVVJJJyxcclxuICAnR09PR0xFX0FJX0tFWSdcclxuXSBhcyBjb25zdDtcclxuXHJcbi8vIE9wdGlvbmFsIGVudmlyb25tZW50IHZhcmlhYmxlcyB3aXRoIGRlZmF1bHRzXHJcbmNvbnN0IE9QVElPTkFMX0VOVl9WQVJTID0ge1xyXG4gIE1PTkdPREJfREJfTkFNRTogJ2NoYXRweWVfZGInLFxyXG4gIE5PREVfRU5WOiAnZGV2ZWxvcG1lbnQnXHJcbn0gYXMgY29uc3Q7XHJcblxyXG4vKipcclxuICogVmFsaWRhdGVzIHRoYXQgYWxsIHJlcXVpcmVkIGVudmlyb25tZW50IHZhcmlhYmxlcyBhcmUgc2V0XHJcbiAqIEB0aHJvd3MgRXJyb3IgaWYgYW55IHJlcXVpcmVkIGVudmlyb25tZW50IHZhcmlhYmxlcyBhcmUgbWlzc2luZ1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRW52KCkge1xyXG4gIC8vIFNraXAgdmFsaWRhdGlvbiBpbiB0ZXN0IGVudmlyb25tZW50XHJcbiAgaWYgKGlzVGVzdEVudmlyb25tZW50KCkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGNvbnN0IG1pc3NpbmcgPSBSRVFVSVJFRF9FTlZfVkFSUy5maWx0ZXIoa2V5ID0+ICFwcm9jZXNzLmVudltrZXldKTtcclxuICBcclxuICBpZiAobWlzc2luZy5sZW5ndGggPiAwKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgIGBNaXNzaW5nIHJlcXVpcmVkIGVudmlyb25tZW50IHZhcmlhYmxlczogJHttaXNzaW5nLmpvaW4oJywgJyl9XFxuYCArXHJcbiAgICAgICdQbGVhc2UgY2hlY2sgeW91ciAuZW52LmxvY2FsIGZpbGUgYW5kIGVuc3VyZSBhbGwgcmVxdWlyZWQgdmFyaWFibGVzIGFyZSBzZXQuJ1xyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIGFuIGVudmlyb25tZW50IHZhcmlhYmxlIHdpdGggdHlwZSBzYWZldHlcclxuICogQHBhcmFtIGtleSBUaGUgZW52aXJvbm1lbnQgdmFyaWFibGUga2V5XHJcbiAqIEByZXR1cm5zIFRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZSB2YWx1ZVxyXG4gKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBub3Qgc2V0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RW52VmFyKGtleTogdHlwZW9mIFJFUVVJUkVEX0VOVl9WQVJTW251bWJlcl0pOiBzdHJpbmcge1xyXG4gIGNvbnN0IHZhbHVlID0gcHJvY2Vzcy5lbnZba2V5XTtcclxuICBpZiAoIXZhbHVlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVudmlyb25tZW50IHZhcmlhYmxlICR7a2V5fSBpcyBub3Qgc2V0YCk7XHJcbiAgfVxyXG4gIHJldHVybiB2YWx1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgYW4gb3B0aW9uYWwgZW52aXJvbm1lbnQgdmFyaWFibGUgd2l0aCBhIGRlZmF1bHQgdmFsdWVcclxuICogQHBhcmFtIGtleSBUaGUgZW52aXJvbm1lbnQgdmFyaWFibGUga2V5XHJcbiAqIEByZXR1cm5zIFRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZSB2YWx1ZSBvciBpdHMgZGVmYXVsdFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE9wdGlvbmFsRW52VmFyPEsgZXh0ZW5kcyBrZXlvZiB0eXBlb2YgT1BUSU9OQUxfRU5WX1ZBUlM+KFxyXG4gIGtleTogS1xyXG4pOiBzdHJpbmcge1xyXG4gIHJldHVybiBwcm9jZXNzLmVudltrZXldIHx8IE9QVElPTkFMX0VOVl9WQVJTW2tleV07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgd2UncmUgcnVubmluZyBpbiBhIHRlc3QgZW52aXJvbm1lbnRcclxuICogQHJldHVybnMgdHJ1ZSBpZiBydW5uaW5nIGluIHRlc3QgZW52aXJvbm1lbnRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1Rlc3RFbnZpcm9ubWVudCgpOiBib29sZWFuIHtcclxuICAvLyBDaGVjayBmb3IgVml0ZXN0J3MgdGVzdCBlbnZpcm9ubWVudFxyXG4gIHJldHVybiBwcm9jZXNzLmVudi5WSVRFU1QgPT09ICd0cnVlJyB8fCBcclxuICAgICAgICAgLy8gQ2hlY2sgZm9yIEplc3QncyB0ZXN0IGVudmlyb25tZW50XHJcbiAgICAgICAgIHByb2Nlc3MuZW52LkpFU1RfV09SS0VSX0lEICE9PSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgLy8gQ2hlY2sgZm9yIE5vZGUncyB0ZXN0IGVudmlyb25tZW50XHJcbiAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCc7XHJcbn1cclxuXHJcbi8vIEV4cG9ydCB0aGUgbW9kdWxlXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2YWxpZGF0ZUVudixcclxuICBnZXRFbnZWYXIsXHJcbiAgZ2V0T3B0aW9uYWxFbnZWYXIsXHJcbiAgaXNUZXN0RW52aXJvbm1lbnRcclxufTsgIl0sIm5hbWVzIjpbIlJFUVVJUkVEX0VOVl9WQVJTIiwiT1BUSU9OQUxfRU5WX1ZBUlMiLCJNT05HT0RCX0RCX05BTUUiLCJOT0RFX0VOViIsInZhbGlkYXRlRW52IiwiaXNUZXN0RW52aXJvbm1lbnQiLCJtaXNzaW5nIiwiZmlsdGVyIiwia2V5IiwicHJvY2VzcyIsImVudiIsImxlbmd0aCIsIkVycm9yIiwiam9pbiIsImdldEVudlZhciIsInZhbHVlIiwiZ2V0T3B0aW9uYWxFbnZWYXIiLCJWSVRFU1QiLCJKRVNUX1dPUktFUl9JRCIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/env.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/gemini.ts":
/*!***************************!*\
  !*** ./src/lib/gemini.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GeminiService: () => (/* binding */ GeminiService),\n/* harmony export */   geminiService: () => (/* binding */ geminiService)\n/* harmony export */ });\n/* harmony import */ var _google_generative_ai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @google/generative-ai */ \"(rsc)/./node_modules/@google/generative-ai/dist/index.mjs\");\n/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./env */ \"(rsc)/./src/lib/env.ts\");\n/* harmony import */ var _mongodb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mongodb */ \"(rsc)/./src/lib/mongodb.ts\");\n\n\n\n// It's good practice to ensure API keys are checked before class instantiation if possible,\n// or at least make it very clear in documentation that the service will fail without them.\nif (!process.env.GEMINI_API_KEY) {\n    console.warn(\"Warning: GEMINI_API_KEY environment variable is not set. GeminiService will fail if instantiated and used.\");\n}\nclass GeminiService {\n    constructor(){\n        const apiKey = (0,_env__WEBPACK_IMPORTED_MODULE_1__.getEnvVar)(\"GEMINI_API_KEY\");\n        if (!apiKey) {\n            throw new Error(\"GEMINI_API_KEY environment variable is not set.\");\n        }\n        this.genAI = new _google_generative_ai__WEBPACK_IMPORTED_MODULE_0__.GoogleGenerativeAI(apiKey);\n        // Define the generation config\n        this.generationConfig = {\n            temperature: 0.7,\n            topK: 1,\n            topP: 1,\n            maxOutputTokens: 2048\n        };\n        // Initialize the model\n        try {\n            this.model = this.genAI.getGenerativeModel({\n                model: \"gemini-1.5-pro\",\n                generationConfig: this.generationConfig\n            });\n        } catch (error) {\n            console.error(\"Failed to initialize Gemini model:\", error);\n            throw new Error(\"Could not initialize Gemini model. Please check your API key and model name.\");\n        }\n    }\n    async validateContexts(contexts, videoId) {\n        if (!contexts || contexts.length === 0) {\n            throw new Error(\"No transcript context provided\");\n        }\n        // Get the videoId from the first context\n        const expectedVideoId = contexts[0].videoId;\n        if (!expectedVideoId) {\n            throw new Error(\"No videoId found in transcript context\");\n        }\n        // Verify that all contexts have the same videoId\n        const mismatchedContexts = contexts.filter((context)=>context.videoId !== expectedVideoId);\n        if (mismatchedContexts.length > 0) {\n            console.error(\"Found contexts with mismatched videoId:\", {\n                expectedVideoId,\n                mismatchedContexts: mismatchedContexts.map((c)=>({\n                        jobId: c.jobId,\n                        actualVideoId: c.videoId\n                    }))\n            });\n            throw new Error(\"Transcript contexts contain mismatched video IDs\");\n        }\n        // Verify that the videoId matches the job for each context\n        for (const context of contexts){\n            const isValid = await (0,_mongodb__WEBPACK_IMPORTED_MODULE_2__.verifyTranscriptVideoId)(context.jobId, expectedVideoId);\n            if (!isValid) {\n                console.error(\"Invalid transcript context:\", {\n                    jobId: context.jobId,\n                    videoId: context.videoId,\n                    expectedVideoId\n                });\n                throw new Error(`Transcript context does not match the provided videoId: ${expectedVideoId}`);\n            }\n        }\n        // Verify timestamp continuity\n        const sortedContexts = [\n            ...contexts\n        ].sort((a, b)=>parseFloat(a.startTimestamp) - parseFloat(b.startTimestamp));\n        for(let i = 1; i < sortedContexts.length; i++){\n            const prevEnd = parseFloat(sortedContexts[i - 1].endTimestamp);\n            const currStart = parseFloat(sortedContexts[i].startTimestamp);\n            if (currStart < prevEnd) {\n                console.error(\"Found overlapping timestamps:\", {\n                    previous: {\n                        jobId: sortedContexts[i - 1].jobId,\n                        end: prevEnd\n                    },\n                    current: {\n                        jobId: sortedContexts[i].jobId,\n                        start: currStart\n                    }\n                });\n                throw new Error(\"Transcript contexts contain overlapping timestamps\");\n            }\n        }\n    }\n    // Unified function for generating answers. Handles both RAG and direct-to-video.\n    async *generateAnswerStream(contexts, question, videoId, videoTitle, videoDescription) {\n        // We still validate if context is provided, to ensure data integrity if it exists.\n        if (contexts.length > 0) {\n            await this.validateContexts(contexts, videoId);\n        } else if (!videoId) {\n            // If there's no context, we MUST have a videoId to proceed.\n            throw new Error(\"Cannot generate answer without transcript context or a videoId.\");\n        }\n        try {\n            if (contexts.length === 0) {\n                // --- Direct-to-video prompt when no transcript is available ---\n                // This now uses the official method for prompting with a YouTube URL.\n                const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;\n                const result = await this.model.generateContentStream([\n                    question,\n                    {\n                        fileData: {\n                            mimeType: \"video/youtube\",\n                            fileUri: videoUrl\n                        }\n                    }\n                ]);\n                for await (const chunk of result.stream){\n                    const chunkText = chunk.text();\n                    yield chunkText;\n                }\n                return; // Exit the generator after handling the direct-to-video case\n            }\n            // This part of the code is now only for the RAG-based approach\n            const chat = this.model.startChat({\n                history: [],\n                generationConfig: this.generationConfig\n            });\n            const transcriptSegments = contexts.map((c)=>`[${c.startTimestamp} - ${c.endTimestamp}] ${c.text}`).join(\"\\n\");\n            const ragPrompt = `\r\n        You are a helpful AI assistant. Answer the user's question based *only* on the following transcript segments from the video.\r\n        Do not use any prior knowledge. If the answer is not in the provided segments, say \"I cannot answer that based on the provided transcript.\"\r\n        When you use information from a segment, cite the start timestamp in your answer, like this: [01:23].\r\n        \r\n        Transcript Segments:\r\n        ---\r\n        ${transcriptSegments}\r\n        ---\r\n        \r\n        User Question: ${question}\r\n      `;\n            const result = await chat.sendMessageStream(ragPrompt);\n            for await (const chunk of result.stream){\n                const chunkText = chunk.text();\n                yield chunkText;\n            }\n        } catch (error) {\n            console.error(\"Error generating answer stream:\", error);\n            yield \"Sorry, I encountered an error while trying to answer your question.\";\n        }\n    }\n}\nconst geminiService = new GeminiService();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFNb0QscUJBQXFCM0MsU0FBU08sR0FBRyxDQUFDQyxDQUFBQSxJQUN0QyxDQUFDLENBQUMsRUFBRUEsRUFBRVMsY0FBYyxDQUFDLEdBQUcsRUFBRVQsRUFBRVksWUFBWSxDQUFDLEVBQUUsRUFBRVosRUFBRStCLElBQUksQ0FBQyxDQUFDLEVBQ3JESyxJQUFJLENBQUM7WUFFUCxNQUFNQyxZQUFZLENBQUM7Ozs7Ozs7UUFPakIsRUFBRUYsbUJBQW1COzs7dUJBR04sRUFBRWhCLFNBQVM7TUFDNUIsQ0FBQztZQUVELE1BQU1JLFNBQVMsTUFBTVMsS0FBS00saUJBQWlCLENBQUNEO1lBRTVDLFdBQVcsTUFBTVQsU0FBU0wsT0FBT00sTUFBTSxDQUFFO2dCQUN2QyxNQUFNQyxZQUFZRixNQUFNRyxJQUFJO2dCQUM1QixNQUFNRDtZQUNSO1FBQ0YsRUFBRSxPQUFPeEMsT0FBTztZQUNkZCxRQUFRYyxLQUFLLENBQUMsbUNBQW1DQTtZQUNqRCxNQUFNO1FBQ1I7SUFDRjtBQTRCRjtBQUVPLE1BQU1pRCxnQkFBZ0IsSUFBSTdELGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRweWUvLi9zcmMvbGliL2dlbWluaS50cz85OTRmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdvb2dsZUdlbmVyYXRpdmVBSSwgR2VuZXJhdGVDb250ZW50UmVzcG9uc2UsIFBhcnQsIEdlbmVyYXRpdmVNb2RlbCwgR2VuZXJhdGlvbkNvbmZpZywgQ29udGVudCB9IGZyb20gXCJAZ29vZ2xlL2dlbmVyYXRpdmUtYWlcIjtcclxuaW1wb3J0IHsgZ2V0RW52VmFyLCBpc1Rlc3RFbnZpcm9ubWVudCB9IGZyb20gJy4vZW52JztcclxuaW1wb3J0IHsgdmVyaWZ5VHJhbnNjcmlwdFZpZGVvSWQgfSBmcm9tICcuL21vbmdvZGInO1xyXG5cclxuLy8gSXQncyBnb29kIHByYWN0aWNlIHRvIGVuc3VyZSBBUEkga2V5cyBhcmUgY2hlY2tlZCBiZWZvcmUgY2xhc3MgaW5zdGFudGlhdGlvbiBpZiBwb3NzaWJsZSxcclxuLy8gb3IgYXQgbGVhc3QgbWFrZSBpdCB2ZXJ5IGNsZWFyIGluIGRvY3VtZW50YXRpb24gdGhhdCB0aGUgc2VydmljZSB3aWxsIGZhaWwgd2l0aG91dCB0aGVtLlxyXG5pZiAoIXByb2Nlc3MuZW52LkdFTUlOSV9BUElfS0VZKSB7XHJcbiAgY29uc29sZS53YXJuKCdXYXJuaW5nOiBHRU1JTklfQVBJX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBub3Qgc2V0LiBHZW1pbmlTZXJ2aWNlIHdpbGwgZmFpbCBpZiBpbnN0YW50aWF0ZWQgYW5kIHVzZWQuJyk7XHJcbn1cclxuXHJcbi8vIERlZmluZSB0aGUgVHJhbnNjcmlwdENvbnRleHQgaW50ZXJmYWNlIHRvIGJlIHVzZWQgYnkgdGhlIHNlcnZpY2VcclxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2NyaXB0Q29udGV4dCB7XHJcbiAgdGV4dDogc3RyaW5nO1xyXG4gIHN0YXJ0VGltZXN0YW1wOiBzdHJpbmc7XHJcbiAgZW5kVGltZXN0YW1wOiBzdHJpbmc7XHJcbiAgam9iSWQ6IHN0cmluZztcclxuICB2aWRlb0lkOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBHZW1pbmlTZXJ2aWNlIHtcclxuICBwcml2YXRlIGdlbkFJOiBHb29nbGVHZW5lcmF0aXZlQUk7XHJcbiAgcHJpdmF0ZSBtb2RlbDogR2VuZXJhdGl2ZU1vZGVsO1xyXG4gIHByaXZhdGUgZ2VuZXJhdGlvbkNvbmZpZzogR2VuZXJhdGlvbkNvbmZpZztcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBjb25zdCBhcGlLZXkgPSBnZXRFbnZWYXIoJ0dFTUlOSV9BUElfS0VZJyk7XHJcbiAgICBpZiAoIWFwaUtleSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dFTUlOSV9BUElfS0VZIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG5vdCBzZXQuJyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmdlbkFJID0gbmV3IEdvb2dsZUdlbmVyYXRpdmVBSShhcGlLZXkpO1xyXG4gICAgXHJcbiAgICAvLyBEZWZpbmUgdGhlIGdlbmVyYXRpb24gY29uZmlnXHJcbiAgICB0aGlzLmdlbmVyYXRpb25Db25maWcgPSB7XHJcbiAgICAgIHRlbXBlcmF0dXJlOiAwLjcsXHJcbiAgICAgIHRvcEs6IDEsXHJcbiAgICAgIHRvcFA6IDEsXHJcbiAgICAgIG1heE91dHB1dFRva2VuczogMjA0OCxcclxuICAgIH07XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgbW9kZWxcclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMubW9kZWwgPSB0aGlzLmdlbkFJLmdldEdlbmVyYXRpdmVNb2RlbCh7IFxyXG4gICAgICAgIG1vZGVsOiBcImdlbWluaS0xLjUtcHJvXCIsXHJcbiAgICAgICAgZ2VuZXJhdGlvbkNvbmZpZzogdGhpcy5nZW5lcmF0aW9uQ29uZmlnIFxyXG4gICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gaW5pdGlhbGl6ZSBHZW1pbmkgbW9kZWw6XCIsIGVycm9yKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGluaXRpYWxpemUgR2VtaW5pIG1vZGVsLiBQbGVhc2UgY2hlY2sgeW91ciBBUEkga2V5IGFuZCBtb2RlbCBuYW1lLlwiKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgdmFsaWRhdGVDb250ZXh0cyhjb250ZXh0czogVHJhbnNjcmlwdENvbnRleHRbXSwgdmlkZW9JZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBpZiAoIWNvbnRleHRzIHx8IGNvbnRleHRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHRyYW5zY3JpcHQgY29udGV4dCBwcm92aWRlZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCB0aGUgdmlkZW9JZCBmcm9tIHRoZSBmaXJzdCBjb250ZXh0XHJcbiAgICBjb25zdCBleHBlY3RlZFZpZGVvSWQgPSBjb250ZXh0c1swXS52aWRlb0lkO1xyXG4gICAgaWYgKCFleHBlY3RlZFZpZGVvSWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB2aWRlb0lkIGZvdW5kIGluIHRyYW5zY3JpcHQgY29udGV4dCcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFZlcmlmeSB0aGF0IGFsbCBjb250ZXh0cyBoYXZlIHRoZSBzYW1lIHZpZGVvSWRcclxuICAgIGNvbnN0IG1pc21hdGNoZWRDb250ZXh0cyA9IGNvbnRleHRzLmZpbHRlcihjb250ZXh0ID0+IGNvbnRleHQudmlkZW9JZCAhPT0gZXhwZWN0ZWRWaWRlb0lkKTtcclxuICAgIGlmIChtaXNtYXRjaGVkQ29udGV4dHMubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGb3VuZCBjb250ZXh0cyB3aXRoIG1pc21hdGNoZWQgdmlkZW9JZDonLCB7XHJcbiAgICAgICAgZXhwZWN0ZWRWaWRlb0lkLFxyXG4gICAgICAgIG1pc21hdGNoZWRDb250ZXh0czogbWlzbWF0Y2hlZENvbnRleHRzLm1hcChjID0+ICh7XHJcbiAgICAgICAgICBqb2JJZDogYy5qb2JJZCxcclxuICAgICAgICAgIGFjdHVhbFZpZGVvSWQ6IGMudmlkZW9JZFxyXG4gICAgICAgIH0pKVxyXG4gICAgICB9KTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2NyaXB0IGNvbnRleHRzIGNvbnRhaW4gbWlzbWF0Y2hlZCB2aWRlbyBJRHMnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBWZXJpZnkgdGhhdCB0aGUgdmlkZW9JZCBtYXRjaGVzIHRoZSBqb2IgZm9yIGVhY2ggY29udGV4dFxyXG4gICAgZm9yIChjb25zdCBjb250ZXh0IG9mIGNvbnRleHRzKSB7XHJcbiAgICAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCB2ZXJpZnlUcmFuc2NyaXB0VmlkZW9JZChjb250ZXh0LmpvYklkLCBleHBlY3RlZFZpZGVvSWQpO1xyXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIHRyYW5zY3JpcHQgY29udGV4dDonLCB7XHJcbiAgICAgICAgICBqb2JJZDogY29udGV4dC5qb2JJZCxcclxuICAgICAgICAgIHZpZGVvSWQ6IGNvbnRleHQudmlkZW9JZCxcclxuICAgICAgICAgIGV4cGVjdGVkVmlkZW9JZFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNjcmlwdCBjb250ZXh0IGRvZXMgbm90IG1hdGNoIHRoZSBwcm92aWRlZCB2aWRlb0lkOiAke2V4cGVjdGVkVmlkZW9JZH1gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFZlcmlmeSB0aW1lc3RhbXAgY29udGludWl0eVxyXG4gICAgY29uc3Qgc29ydGVkQ29udGV4dHMgPSBbLi4uY29udGV4dHNdLnNvcnQoKGEsIGIpID0+IFxyXG4gICAgICBwYXJzZUZsb2F0KGEuc3RhcnRUaW1lc3RhbXApIC0gcGFyc2VGbG9hdChiLnN0YXJ0VGltZXN0YW1wKVxyXG4gICAgKTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNvcnRlZENvbnRleHRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHByZXZFbmQgPSBwYXJzZUZsb2F0KHNvcnRlZENvbnRleHRzW2ktMV0uZW5kVGltZXN0YW1wKTtcclxuICAgICAgY29uc3QgY3VyclN0YXJ0ID0gcGFyc2VGbG9hdChzb3J0ZWRDb250ZXh0c1tpXS5zdGFydFRpbWVzdGFtcCk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoY3VyclN0YXJ0IDwgcHJldkVuZCkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZvdW5kIG92ZXJsYXBwaW5nIHRpbWVzdGFtcHM6Jywge1xyXG4gICAgICAgICAgcHJldmlvdXM6IHtcclxuICAgICAgICAgICAgam9iSWQ6IHNvcnRlZENvbnRleHRzW2ktMV0uam9iSWQsXHJcbiAgICAgICAgICAgIGVuZDogcHJldkVuZFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGN1cnJlbnQ6IHtcclxuICAgICAgICAgICAgam9iSWQ6IHNvcnRlZENvbnRleHRzW2ldLmpvYklkLFxyXG4gICAgICAgICAgICBzdGFydDogY3VyclN0YXJ0XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2NyaXB0IGNvbnRleHRzIGNvbnRhaW4gb3ZlcmxhcHBpbmcgdGltZXN0YW1wcycpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBVbmlmaWVkIGZ1bmN0aW9uIGZvciBnZW5lcmF0aW5nIGFuc3dlcnMuIEhhbmRsZXMgYm90aCBSQUcgYW5kIGRpcmVjdC10by12aWRlby5cclxuICBhc3luYyAqZ2VuZXJhdGVBbnN3ZXJTdHJlYW0oXHJcbiAgICBjb250ZXh0czogQXJyYXk8VHJhbnNjcmlwdENvbnRleHQ+LCBcclxuICAgIHF1ZXN0aW9uOiBzdHJpbmcsIFxyXG4gICAgdmlkZW9JZDogc3RyaW5nLFxyXG4gICAgdmlkZW9UaXRsZT86IHN0cmluZyxcclxuICAgIHZpZGVvRGVzY3JpcHRpb24/OiBzdHJpbmdcclxuICApOiBBc3luY0dlbmVyYXRvcjxzdHJpbmc+IHtcclxuICAgIFxyXG4gICAgLy8gV2Ugc3RpbGwgdmFsaWRhdGUgaWYgY29udGV4dCBpcyBwcm92aWRlZCwgdG8gZW5zdXJlIGRhdGEgaW50ZWdyaXR5IGlmIGl0IGV4aXN0cy5cclxuICAgIGlmIChjb250ZXh0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGF3YWl0IHRoaXMudmFsaWRhdGVDb250ZXh0cyhjb250ZXh0cywgdmlkZW9JZCk7XHJcbiAgICB9IGVsc2UgaWYgKCF2aWRlb0lkKSB7XHJcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gY29udGV4dCwgd2UgTVVTVCBoYXZlIGEgdmlkZW9JZCB0byBwcm9jZWVkLlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2VuZXJhdGUgYW5zd2VyIHdpdGhvdXQgdHJhbnNjcmlwdCBjb250ZXh0IG9yIGEgdmlkZW9JZC5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKGNvbnRleHRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIC8vIC0tLSBEaXJlY3QtdG8tdmlkZW8gcHJvbXB0IHdoZW4gbm8gdHJhbnNjcmlwdCBpcyBhdmFpbGFibGUgLS0tXHJcbiAgICAgICAgLy8gVGhpcyBub3cgdXNlcyB0aGUgb2ZmaWNpYWwgbWV0aG9kIGZvciBwcm9tcHRpbmcgd2l0aCBhIFlvdVR1YmUgVVJMLlxyXG4gICAgICAgIGNvbnN0IHZpZGVvVXJsID0gYGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9JHt2aWRlb0lkfWA7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5tb2RlbC5nZW5lcmF0ZUNvbnRlbnRTdHJlYW0oW1xyXG4gICAgICAgICAgcXVlc3Rpb24sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGZpbGVEYXRhOiB7XHJcbiAgICAgICAgICAgICAgbWltZVR5cGU6IFwidmlkZW8veW91dHViZVwiLFxyXG4gICAgICAgICAgICAgIGZpbGVVcmk6IHZpZGVvVXJsLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICBdKTtcclxuICAgICAgICBcclxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHJlc3VsdC5zdHJlYW0pIHtcclxuICAgICAgICAgIGNvbnN0IGNodW5rVGV4dCA9IGNodW5rLnRleHQoKTtcclxuICAgICAgICAgIHlpZWxkIGNodW5rVGV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuOyAvLyBFeGl0IHRoZSBnZW5lcmF0b3IgYWZ0ZXIgaGFuZGxpbmcgdGhlIGRpcmVjdC10by12aWRlbyBjYXNlXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIFRoaXMgcGFydCBvZiB0aGUgY29kZSBpcyBub3cgb25seSBmb3IgdGhlIFJBRy1iYXNlZCBhcHByb2FjaFxyXG4gICAgICBjb25zdCBjaGF0ID0gdGhpcy5tb2RlbC5zdGFydENoYXQoe1xyXG4gICAgICAgIGhpc3Rvcnk6IFtdLFxyXG4gICAgICAgIGdlbmVyYXRpb25Db25maWc6IHRoaXMuZ2VuZXJhdGlvbkNvbmZpZ1xyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHRyYW5zY3JpcHRTZWdtZW50cyA9IGNvbnRleHRzLm1hcChjID0+IFxyXG4gICAgICAgIGBbJHtjLnN0YXJ0VGltZXN0YW1wfSAtICR7Yy5lbmRUaW1lc3RhbXB9XSAke2MudGV4dH1gXHJcbiAgICAgICkuam9pbignXFxuJyk7XHJcblxyXG4gICAgICBjb25zdCByYWdQcm9tcHQgPSBgXHJcbiAgICAgICAgWW91IGFyZSBhIGhlbHBmdWwgQUkgYXNzaXN0YW50LiBBbnN3ZXIgdGhlIHVzZXIncyBxdWVzdGlvbiBiYXNlZCAqb25seSogb24gdGhlIGZvbGxvd2luZyB0cmFuc2NyaXB0IHNlZ21lbnRzIGZyb20gdGhlIHZpZGVvLlxyXG4gICAgICAgIERvIG5vdCB1c2UgYW55IHByaW9yIGtub3dsZWRnZS4gSWYgdGhlIGFuc3dlciBpcyBub3QgaW4gdGhlIHByb3ZpZGVkIHNlZ21lbnRzLCBzYXkgXCJJIGNhbm5vdCBhbnN3ZXIgdGhhdCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgdHJhbnNjcmlwdC5cIlxyXG4gICAgICAgIFdoZW4geW91IHVzZSBpbmZvcm1hdGlvbiBmcm9tIGEgc2VnbWVudCwgY2l0ZSB0aGUgc3RhcnQgdGltZXN0YW1wIGluIHlvdXIgYW5zd2VyLCBsaWtlIHRoaXM6IFswMToyM10uXHJcbiAgICAgICAgXHJcbiAgICAgICAgVHJhbnNjcmlwdCBTZWdtZW50czpcclxuICAgICAgICAtLS1cclxuICAgICAgICAke3RyYW5zY3JpcHRTZWdtZW50c31cclxuICAgICAgICAtLS1cclxuICAgICAgICBcclxuICAgICAgICBVc2VyIFF1ZXN0aW9uOiAke3F1ZXN0aW9ufVxyXG4gICAgICBgO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2hhdC5zZW5kTWVzc2FnZVN0cmVhbShyYWdQcm9tcHQpO1xyXG5cclxuICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiByZXN1bHQuc3RyZWFtKSB7XHJcbiAgICAgICAgY29uc3QgY2h1bmtUZXh0ID0gY2h1bmsudGV4dCgpO1xyXG4gICAgICAgIHlpZWxkIGNodW5rVGV4dDtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyBhbnN3ZXIgc3RyZWFtOicsIGVycm9yKTtcclxuICAgICAgeWllbGQgXCJTb3JyeSwgSSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSB0cnlpbmcgdG8gYW5zd2VyIHlvdXIgcXVlc3Rpb24uXCI7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG5vdyByZWR1bmRhbnQgYW5kIHdpbGwgYmUgcmVtb3ZlZC5cclxuICAvKlxyXG4gIGFzeW5jICpnZW5lcmF0ZUFuc3dlckZyb21Zb3VUdWJlVXJsRGlyZWN0bHkoeW91dHViZVVybDogc3RyaW5nLCBxdWVzdGlvbjogc3RyaW5nKTogQXN5bmNHZW5lcmF0b3I8c3RyaW5nPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB2aWRlb0lkID0gZXh0cmFjdFZpZGVvSWQoeW91dHViZVVybCk7XHJcbiAgICAgIGlmICghdmlkZW9JZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBZb3VUdWJlIFVSTCBwcm92aWRlZC4nKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgcHJvbXB0ID0gYFxyXG4gICAgICAgIFBsZWFzZSBhbnN3ZXIgdGhlIGZvbGxvd2luZyBxdWVzdGlvbiBhYm91dCB0aGUgWW91VHViZSB2aWRlbyBhdCB0aGlzIFVSTDogJHt5b3V0dWJlVXJsfS5cclxuICAgICAgICBRdWVzdGlvbjogJHtxdWVzdGlvbn1cclxuICAgICAgYDtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMubW9kZWwuZ2VuZXJhdGVDb250ZW50U3RyZWFtKFtwcm9tcHRdKTtcclxuXHJcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmVzdWx0LnN0cmVhbSkge1xyXG4gICAgICAgIGNvbnN0IGNodW5rVGV4dCA9IGNodW5rLnRleHQoKTtcclxuICAgICAgICB5aWVsZCBjaHVua1RleHQ7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdlbmVyYXRlQW5zd2VyRnJvbVlvdVR1YmVVcmxEaXJlY3RseTonLCBlcnJvcik7XHJcbiAgICAgIHlpZWxkIFwiU29ycnksIHRoZXJlIHdhcyBhbiBlcnJvciBwcm9jZXNzaW5nIHRoZSB2aWRlbyBkaXJlY3RseS5cIjtcclxuICAgIH1cclxuICB9XHJcbiAgKi9cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGdlbWluaVNlcnZpY2UgPSBuZXcgR2VtaW5pU2VydmljZSgpOyAiXSwibmFtZXMiOlsiR29vZ2xlR2VuZXJhdGl2ZUFJIiwiZ2V0RW52VmFyIiwidmVyaWZ5VHJhbnNjcmlwdFZpZGVvSWQiLCJwcm9jZXNzIiwiZW52IiwiR0VNSU5JX0FQSV9LRVkiLCJjb25zb2xlIiwid2FybiIsIkdlbWluaVNlcnZpY2UiLCJjb25zdHJ1Y3RvciIsImFwaUtleSIsIkVycm9yIiwiZ2VuQUkiLCJnZW5lcmF0aW9uQ29uZmlnIiwidGVtcGVyYXR1cmUiLCJ0b3BLIiwidG9wUCIsIm1heE91dHB1dFRva2VucyIsIm1vZGVsIiwiZ2V0R2VuZXJhdGl2ZU1vZGVsIiwiZXJyb3IiLCJ2YWxpZGF0ZUNvbnRleHRzIiwiY29udGV4dHMiLCJ2aWRlb0lkIiwibGVuZ3RoIiwiZXhwZWN0ZWRWaWRlb0lkIiwibWlzbWF0Y2hlZENvbnRleHRzIiwiZmlsdGVyIiwiY29udGV4dCIsIm1hcCIsImMiLCJqb2JJZCIsImFjdHVhbFZpZGVvSWQiLCJpc1ZhbGlkIiwic29ydGVkQ29udGV4dHMiLCJzb3J0IiwiYSIsImIiLCJwYXJzZUZsb2F0Iiwic3RhcnRUaW1lc3RhbXAiLCJpIiwicHJldkVuZCIsImVuZFRpbWVzdGFtcCIsImN1cnJTdGFydCIsInByZXZpb3VzIiwiZW5kIiwiY3VycmVudCIsInN0YXJ0IiwiZ2VuZXJhdGVBbnN3ZXJTdHJlYW0iLCJxdWVzdGlvbiIsInZpZGVvVGl0bGUiLCJ2aWRlb0Rlc2NyaXB0aW9uIiwidmlkZW9VcmwiLCJyZXN1bHQiLCJnZW5lcmF0ZUNvbnRlbnRTdHJlYW0iLCJmaWxlRGF0YSIsIm1pbWVUeXBlIiwiZmlsZVVyaSIsImNodW5rIiwic3RyZWFtIiwiY2h1bmtUZXh0IiwidGV4dCIsImNoYXQiLCJzdGFydENoYXQiLCJoaXN0b3J5IiwidHJhbnNjcmlwdFNlZ21lbnRzIiwiam9pbiIsInJhZ1Byb21wdCIsInNlbmRNZXNzYWdlU3RyZWFtIiwiZ2VtaW5pU2VydmljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/gemini.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/mongodb.ts":
/*!****************************!*\
  !*** ./src/lib/mongodb.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeDatabaseConnection: () => (/* binding */ closeDatabaseConnection),\n/* harmony export */   connectToDatabase: () => (/* binding */ connectToDatabase),\n/* harmony export */   createTranscriptChunks: () => (/* binding */ createTranscriptChunks),\n/* harmony export */   createVideoJob: () => (/* binding */ createVideoJob),\n/* harmony export */   getCachedProactiveAnalysis: () => (/* binding */ getCachedProactiveAnalysis),\n/* harmony export */   getCachedQAResponse: () => (/* binding */ getCachedQAResponse),\n/* harmony export */   getCollections: () => (/* binding */ getCollections),\n/* harmony export */   getTranscriptChunks: () => (/* binding */ getTranscriptChunks),\n/* harmony export */   getTranscriptChunksByVideoId: () => (/* binding */ getTranscriptChunksByVideoId),\n/* harmony export */   getUserTranscriptChunks: () => (/* binding */ getUserTranscriptChunks),\n/* harmony export */   getVideoJob: () => (/* binding */ getVideoJob),\n/* harmony export */   saveQAResponse: () => (/* binding */ saveQAResponse),\n/* harmony export */   updateTranscriptChunkEmbeddings: () => (/* binding */ updateTranscriptChunkEmbeddings),\n/* harmony export */   updateVideoJob: () => (/* binding */ updateVideoJob),\n/* harmony export */   verifyTranscriptOwnership: () => (/* binding */ verifyTranscriptOwnership),\n/* harmony export */   verifyTranscriptVideoId: () => (/* binding */ verifyTranscriptVideoId)\n/* harmony export */ });\n/* harmony import */ var mongodb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mongodb */ \"mongodb\");\n/* harmony import */ var mongodb__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mongodb__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./env */ \"(rsc)/./src/lib/env.ts\");\n\n\n// MongoDB connection state\nlet client = null;\nlet db = null;\n// Collection references with proper typing\nlet videoJobsCollection = null;\nlet transcriptChunksCollection = null;\nlet cachedVideoQACollection = null;\n/**\r\n * Connects to the MongoDB database\r\n * @throws Error if connection fails or required environment variables are missing\r\n */ async function connectToDatabase() {\n    if (db && client) {\n        return {\n            db,\n            client\n        };\n    }\n    try {\n        // Get MongoDB URI from environment\n        const uri = (0,_env__WEBPACK_IMPORTED_MODULE_1__.isTestEnvironment)() ? process.env.MONGODB_URI : (0,_env__WEBPACK_IMPORTED_MODULE_1__.getEnvVar)(\"MONGODB_URI\");\n        if (!uri) {\n            throw new Error(\"MONGODB_URI is not set\");\n        }\n        // Connect to MongoDB\n        client = new mongodb__WEBPACK_IMPORTED_MODULE_0__.MongoClient(uri);\n        await client.connect();\n        // Get database name from environment or use default\n        const dbName = (0,_env__WEBPACK_IMPORTED_MODULE_1__.getOptionalEnvVar)(\"MONGODB_DB_NAME\");\n        db = client.db(dbName);\n        // Initialize collections with proper typing\n        videoJobsCollection = db.collection(\"videoJobs\");\n        transcriptChunksCollection = db.collection(\"transcriptChunks\");\n        cachedVideoQACollection = db.collection(\"cachedQAResponses\");\n        // Create indexes\n        await videoJobsCollection.createIndex({\n            jobId: 1\n        }, {\n            unique: true\n        });\n        await videoJobsCollection.createIndex({\n            \"processingMetadata.videoId\": 1\n        });\n        await transcriptChunksCollection.createIndex({\n            jobId: 1\n        });\n        await transcriptChunksCollection.createIndex({\n            \"metadata.videoId\": 1\n        });\n        return {\n            db,\n            client\n        };\n    } catch (error) {\n        console.error(\"Failed to connect to MongoDB:\", error);\n        throw error;\n    }\n}\n// Export a function to get specific collections, ensuring DB connection\nasync function getCollections() {\n    if (!db || !client) {\n        await connectToDatabase();\n    }\n    // Return collections with proper typing\n    return {\n        videoJobsCollection: videoJobsCollection || undefined,\n        transcriptChunksCollection: transcriptChunksCollection || undefined,\n        cachedVideoQACollection: cachedVideoQACollection || undefined\n    };\n}\n// --- Video Job Functions ---\nasync function createVideoJob(jobData) {\n    const { videoJobsCollection } = await getCollections();\n    if (!videoJobsCollection) throw new Error(\"videoJobsCollection not initialized\");\n    const newJob = {\n        ...jobData,\n        status: jobData.status || \"pending\",\n        createdAt: new Date(),\n        updatedAt: new Date()\n    };\n    const result = await videoJobsCollection.insertOne(newJob);\n    if (!result.insertedId) {\n        throw new Error(\"Failed to create video job.\");\n    }\n    return {\n        ...newJob,\n        _id: result.insertedId\n    };\n}\nasync function getVideoJob(jobId) {\n    const { videoJobsCollection } = await getCollections();\n    if (!videoJobsCollection) throw new Error(\"videoJobsCollection not initialized\");\n    return videoJobsCollection.findOne({\n        jobId\n    });\n}\nasync function updateVideoJob(jobId, updates) {\n    const { videoJobsCollection } = await getCollections();\n    if (!videoJobsCollection) throw new Error(\"videoJobsCollection not initialized\");\n    const result = await videoJobsCollection.updateOne({\n        jobId\n    }, {\n        $set: {\n            ...updates,\n            updatedAt: new Date()\n        }\n    });\n    return result.modifiedCount > 0;\n}\n// --- Transcript Chunk Functions ---\nasync function createTranscriptChunks(chunksData) {\n    const { transcriptChunksCollection } = await getCollections();\n    if (!transcriptChunksCollection) throw new Error(\"transcriptChunksCollection not initialized\");\n    if (chunksData.length === 0) return;\n    const chunksToInsert = chunksData.map((chunk)=>({\n            ...chunk,\n            createdAt: new Date()\n        }));\n    try {\n        // First, delete any existing chunks for this job and user\n        if (chunksToInsert.length > 0) {\n            await transcriptChunksCollection.deleteMany({\n                jobId: chunksToInsert[0].jobId,\n                userId: chunksToInsert[0].userId\n            });\n        }\n        // Then insert the new chunks\n        const result = await transcriptChunksCollection.insertMany(chunksToInsert);\n        console.log(`Successfully inserted ${result.insertedCount} transcript chunks`);\n    } catch (error) {\n        console.error(\"Error in createTranscriptChunks:\", error);\n        throw new Error(`Failed to create transcript chunks: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n}\nasync function getTranscriptChunks(jobId) {\n    const { transcriptChunksCollection } = await getCollections();\n    if (!transcriptChunksCollection) throw new Error(\"transcriptChunksCollection not initialized\");\n    return transcriptChunksCollection.find({\n        jobId\n    }).sort({\n        startTimestamp: 1\n    }).toArray(); // Sort by start time\n}\nasync function updateTranscriptChunkEmbeddings(jobId, chunkId, embedding) {\n    const { transcriptChunksCollection } = await getCollections();\n    if (!transcriptChunksCollection) throw new Error(\"transcriptChunksCollection not initialized\");\n    const result = await transcriptChunksCollection.updateOne({\n        jobId,\n        chunkId\n    }, {\n        $set: {\n            embedding\n        }\n    });\n    return result.modifiedCount > 0;\n}\n// Add a new function to get user-specific transcript chunks\nasync function getUserTranscriptChunks(jobId, userId) {\n    const { transcriptChunksCollection } = await getCollections();\n    if (!transcriptChunksCollection) throw new Error(\"transcriptChunksCollection not initialized\");\n    return transcriptChunksCollection.find({\n        jobId,\n        userId\n    }).sort({\n        startTimestamp: 1\n    }).toArray();\n}\n// Add a function to verify transcript ownership\nasync function verifyTranscriptOwnership(jobId, userId) {\n    const { videoJobsCollection } = await getCollections();\n    if (!videoJobsCollection) throw new Error(\"videoJobsCollection not initialized\");\n    const job = await videoJobsCollection.findOne({\n        jobId,\n        userId\n    });\n    return !!job;\n}\n// Add type-safe transcript retrieval function\nasync function getTranscriptChunksByVideoId(videoId, userId) {\n    const { transcriptChunksCollection } = await getCollections();\n    if (!transcriptChunksCollection) throw new Error(\"transcriptChunksCollection not initialized\");\n    return transcriptChunksCollection.find({\n        \"metadata.videoId\": videoId,\n        userId\n    }).toArray();\n}\n// Add function to verify transcript-videoId match\nasync function verifyTranscriptVideoId(jobId, videoId) {\n    const { videoJobsCollection } = await getCollections();\n    if (!videoJobsCollection) throw new Error(\"videoJobsCollection not initialized\");\n    const job = await videoJobsCollection.findOne({\n        jobId,\n        \"processingMetadata.videoId\": videoId\n    });\n    return !!job;\n}\n// --- Q&A Cache Functions ---\nasync function getCachedQAResponse(jobId, normalizedQuestionText, modelUsed) {\n    const { cachedVideoQACollection } = await getCollections();\n    if (!cachedVideoQACollection) throw new Error(\"cachedVideoQACollection not initialized\");\n    // console.log(`CACHE_LOOKUP: jobId=${jobId}, question='${normalizedQuestionText}', model='${modelUsed}'`); // Debug\n    const response = await cachedVideoQACollection.findOne({\n        jobId,\n        questionTextNormalized: normalizedQuestionText,\n        modelUsed,\n        cacheType: \"user_question\"\n    });\n    // if (response) console.log(\"CACHE_HIT\"); else console.log(\"CACHE_MISS\"); // Debug\n    return response;\n}\nasync function getCachedProactiveAnalysis(jobId, analysisType, modelUsed) {\n    const { cachedVideoQACollection } = await getCollections();\n    if (!cachedVideoQACollection) throw new Error(\"cachedVideoQACollection not initialized\");\n    return cachedVideoQACollection.findOne({\n        jobId,\n        analysisType,\n        modelUsed,\n        cacheType: \"proactive_analysis\"\n    });\n}\nasync function saveQAResponse(jobId, questionOrAnalysisType, modelUsed, responseText, cacheType = \"user_question\" // Default to user_question\n) {\n    const { cachedVideoQACollection } = await getCollections();\n    if (!cachedVideoQACollection) throw new Error(\"cachedVideoQACollection not initialized\");\n    const now = new Date();\n    let filter;\n    let updateData;\n    if (cacheType === \"user_question\") {\n        filter = {\n            jobId,\n            questionTextNormalized: questionOrAnalysisType,\n            modelUsed,\n            cacheType\n        };\n        updateData = {\n            $set: {\n                responseText,\n                updatedAt: now\n            },\n            $setOnInsert: {\n                jobId,\n                questionTextNormalized: questionOrAnalysisType,\n                modelUsed,\n                cacheType,\n                createdAt: now\n            }\n        };\n    } else {\n        filter = {\n            jobId,\n            analysisType: questionOrAnalysisType,\n            modelUsed,\n            cacheType\n        };\n        updateData = {\n            $set: {\n                responseText,\n                updatedAt: now\n            },\n            $setOnInsert: {\n                jobId,\n                analysisType: questionOrAnalysisType,\n                modelUsed,\n                cacheType,\n                createdAt: now\n            }\n        };\n    }\n    try {\n        // console.log(`CACHE_SAVE: jobId=${jobId}, key='${questionOrAnalysisType}', model='${modelUsed}', type='${cacheType}'`); // Debug\n        await cachedVideoQACollection.updateOne(filter, updateData, {\n            upsert: true\n        });\n    // console.log(\"CACHE_SAVE successful\"); // Debug\n    } catch (error) {\n        console.error(\"Error saving Q&A response to cache:\", error);\n    // Decide if this error should be propagated or just logged\n    // For async background saves, logging might be sufficient.\n    }\n}\n// Optional: Function to clear MongoDB client connection (e.g., for graceful shutdown)\nasync function closeDatabaseConnection() {\n    if (client) {\n        await client.close();\n        client = null;\n        db = null;\n        console.log(\"MongoDB connection closed.\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNwQixJQUFJakYsUUFBUTtRQUNWLE1BQU1BLE9BQU9rRixLQUFLO1FBQ2xCbEYsU0FBUztRQUNUQyxLQUFLO1FBQ0xpQixRQUFROEIsR0FBRyxDQUFDO0lBQ2Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRweWUvLi9zcmMvbGliL21vbmdvZGIudHM/NTNjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb2xsZWN0aW9uLCBEYiwgTW9uZ29DbGllbnQsIFNlcnZlckFwaVZlcnNpb24sIE9iamVjdElkIH0gZnJvbSAnbW9uZ29kYic7XHJcbmltcG9ydCB7IGdldEVudlZhciwgZ2V0T3B0aW9uYWxFbnZWYXIsIGlzVGVzdEVudmlyb25tZW50IH0gZnJvbSAnLi9lbnYnO1xyXG5cclxuLy8gRGVmaW5lIGludGVyZmFjZXMgZm9yIHlvdXIgZGF0YSBzdHJ1Y3R1cmVzXHJcbmV4cG9ydCBpbnRlcmZhY2UgVmlkZW9Kb2Ige1xyXG4gIF9pZD86IE9iamVjdElkO1xyXG4gIGpvYklkOiBzdHJpbmc7XHJcbiAgeW91dHViZVVybDogc3RyaW5nO1xyXG4gIHVzZXJJZDogc3RyaW5nOyAgICAgICAgICAgLy8gQWRkIHVzZXIgSUQgdG8gdHJhY2sgb3duZXJzaGlwXHJcbiAgc3RhdHVzOiAncGVuZGluZycgfCAncHJvY2Vzc2luZycgfCAnY29tcGxldGVkJyB8ICdmYWlsZWQnO1xyXG4gIHRyYW5zY3JpcHRTdGF0dXM/OiAncHJvY2Vzc2luZycgfCAnZm91bmQnIHwgJ25vdF9mb3VuZCcgfCAnZmFpbGVkJyB8ICdlcnJvcic7XHJcbiAgcHJvZ3Jlc3M/OiBzdHJpbmc7IC8vIE9wdGlvbmFsIHByb2dyZXNzIG1lc3NhZ2VcclxuICBjcmVhdGVkQXQ/OiBEYXRlO1xyXG4gIHVwZGF0ZWRBdD86IERhdGU7XHJcbiAgcHJvY2Vzc2luZ01ldGFkYXRhPzoge1xyXG4gICAgdmlkZW9JZDogc3RyaW5nO1xyXG4gICAgdmlkZW9UaXRsZT86IHN0cmluZztcclxuICAgIHByb2Nlc3NpbmdTdGFydFRpbWU/OiBEYXRlO1xyXG4gICAgcHJvY2Vzc2luZ0VuZFRpbWU/OiBEYXRlO1xyXG4gICAgdHJhbnNjcmlwdFNvdXJjZT86ICd5b3V0dWJlJyB8ICdtYW51YWwnIHwgJ3JldXNlZCc7XHJcbiAgICBvcmlnaW5hbEpvYklkPzogc3RyaW5nOyAgLy8gSWYgdGhpcyBpcyBhIHJldXNlZCB0cmFuc2NyaXB0LCB0cmFjayB0aGUgb3JpZ2luYWwgam9iXHJcbiAgfTtcclxuICAvLyBZb3UgbWlnaHQgYWRkIG1vcmUgZmllbGRzIGxpa2UgdmlkZW9UaXRsZSwgZHVyYXRpb24sIGV0Yy5cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2NyaXB0Q2h1bmsge1xyXG4gIF9pZD86IE9iamVjdElkO1xyXG4gIGpvYklkOiBzdHJpbmc7XHJcbiAgdXNlcklkOiBzdHJpbmc7XHJcbiAgY2h1bmtJZDogc3RyaW5nO1xyXG4gIHRleHRDb250ZW50OiBzdHJpbmc7XHJcbiAgc3RhcnRUaW1lc3RhbXA6IHN0cmluZztcclxuICBlbmRUaW1lc3RhbXA6IHN0cmluZztcclxuICBzZWdtZW50Q291bnQ6IG51bWJlcjtcclxuICBlbWJlZGRpbmc6IG51bWJlcltdO1xyXG4gIG1ldGFkYXRhOiB7XHJcbiAgICBwcm9jZXNzaW5nVmVyc2lvbjogbnVtYmVyO1xyXG4gICAgdmlkZW9JZDogc3RyaW5nO1xyXG4gICAgb3JpZ2luYWxKb2JJZD86IHN0cmluZztcclxuICB9O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENhY2hlZFFBUmVzcG9uc2Uge1xyXG4gIF9pZD86IE9iamVjdElkO1xyXG4gIGpvYklkOiBzdHJpbmc7IC8vIFJlZmVyZW5jZXMgdGhlIFZpZGVvSm9iLmpvYklkIChpZGVudGlmaWVzIHRoZSB2aWRlbylcclxuICBjYWNoZVR5cGU6ICd1c2VyX3F1ZXN0aW9uJyB8ICdwcm9hY3RpdmVfYW5hbHlzaXMnO1xyXG4gIHF1ZXN0aW9uVGV4dE5vcm1hbGl6ZWQ/OiBzdHJpbmc7IC8vIEZvciB1c2VyX3F1ZXN0aW9uIHR5cGVcclxuICBhbmFseXNpc1R5cGU/OiBzdHJpbmc7IC8vIEZvciBwcm9hY3RpdmVfYW5hbHlzaXMgdHlwZSAoZS5nLiwgXCJwcm9hY3RpdmVfc3VtbWFyeV90b3BpY3NfdGFrZWF3YXlzXCIpXHJcbiAgcmVzcG9uc2VUZXh0OiBzdHJpbmc7XHJcbiAgbW9kZWxVc2VkOiBzdHJpbmc7IC8vIGUuZy4sIFwiZ2VtaW5pLTEuNS1wcm8tZGlyZWN0LXlvdXR1YmVcIlxyXG4gIGNyZWF0ZWRBdDogRGF0ZTtcclxuICB1cGRhdGVkQXQ6IERhdGU7IC8vIFRvIGtub3cgd2hlbiBpdCB3YXMgbGFzdCB1cGRhdGVkIChmb3IgdXBzZXJ0KVxyXG4gIC8vIHNvdXJjZUxhbmd1YWdlPzogc3RyaW5nOyAvLyBGdXR1cmUgdXNlXHJcbiAgLy8gc3RydWN0dXJlZFJlc3BvbnNlRGF0YT86IGFueTsgLy8gRnV0dXJlIHVzZSBmb3Igc3RydWN0dXJlZCBwcm9hY3RpdmUgYW5hbHlzaXNcclxufVxyXG5cclxuLy8gTW9uZ29EQiBjb25uZWN0aW9uIHN0YXRlXHJcbmxldCBjbGllbnQ6IE1vbmdvQ2xpZW50IHwgbnVsbCA9IG51bGw7XHJcbmxldCBkYjogRGIgfCBudWxsID0gbnVsbDtcclxuXHJcbi8vIENvbGxlY3Rpb24gcmVmZXJlbmNlcyB3aXRoIHByb3BlciB0eXBpbmdcclxubGV0IHZpZGVvSm9ic0NvbGxlY3Rpb246IENvbGxlY3Rpb248VmlkZW9Kb2I+IHwgbnVsbCA9IG51bGw7XHJcbmxldCB0cmFuc2NyaXB0Q2h1bmtzQ29sbGVjdGlvbjogQ29sbGVjdGlvbjxUcmFuc2NyaXB0Q2h1bms+IHwgbnVsbCA9IG51bGw7XHJcbmxldCBjYWNoZWRWaWRlb1FBQ29sbGVjdGlvbjogQ29sbGVjdGlvbjxDYWNoZWRRQVJlc3BvbnNlPiB8IG51bGwgPSBudWxsO1xyXG5cclxuLyoqXHJcbiAqIENvbm5lY3RzIHRvIHRoZSBNb25nb0RCIGRhdGFiYXNlXHJcbiAqIEB0aHJvd3MgRXJyb3IgaWYgY29ubmVjdGlvbiBmYWlscyBvciByZXF1aXJlZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYXJlIG1pc3NpbmdcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb25uZWN0VG9EYXRhYmFzZSgpIHtcclxuICBpZiAoZGIgJiYgY2xpZW50KSB7XHJcbiAgICByZXR1cm4geyBkYiwgY2xpZW50IH07XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgLy8gR2V0IE1vbmdvREIgVVJJIGZyb20gZW52aXJvbm1lbnRcclxuICAgIGNvbnN0IHVyaSA9IGlzVGVzdEVudmlyb25tZW50KCkgXHJcbiAgICAgID8gcHJvY2Vzcy5lbnYuTU9OR09EQl9VUkkgXHJcbiAgICAgIDogZ2V0RW52VmFyKCdNT05HT0RCX1VSSScpO1xyXG5cclxuICAgIGlmICghdXJpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignTU9OR09EQl9VUkkgaXMgbm90IHNldCcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbm5lY3QgdG8gTW9uZ29EQlxyXG4gICAgY2xpZW50ID0gbmV3IE1vbmdvQ2xpZW50KHVyaSk7XHJcbiAgICBhd2FpdCBjbGllbnQuY29ubmVjdCgpO1xyXG5cclxuICAgIC8vIEdldCBkYXRhYmFzZSBuYW1lIGZyb20gZW52aXJvbm1lbnQgb3IgdXNlIGRlZmF1bHRcclxuICAgIGNvbnN0IGRiTmFtZSA9IGdldE9wdGlvbmFsRW52VmFyKCdNT05HT0RCX0RCX05BTUUnKTtcclxuICAgIGRiID0gY2xpZW50LmRiKGRiTmFtZSk7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSBjb2xsZWN0aW9ucyB3aXRoIHByb3BlciB0eXBpbmdcclxuICAgIHZpZGVvSm9ic0NvbGxlY3Rpb24gPSBkYi5jb2xsZWN0aW9uPFZpZGVvSm9iPigndmlkZW9Kb2JzJyk7XHJcbiAgICB0cmFuc2NyaXB0Q2h1bmtzQ29sbGVjdGlvbiA9IGRiLmNvbGxlY3Rpb248VHJhbnNjcmlwdENodW5rPigndHJhbnNjcmlwdENodW5rcycpO1xyXG4gICAgY2FjaGVkVmlkZW9RQUNvbGxlY3Rpb24gPSBkYi5jb2xsZWN0aW9uPENhY2hlZFFBUmVzcG9uc2U+KCdjYWNoZWRRQVJlc3BvbnNlcycpO1xyXG5cclxuICAgIC8vIENyZWF0ZSBpbmRleGVzXHJcbiAgICBhd2FpdCB2aWRlb0pvYnNDb2xsZWN0aW9uLmNyZWF0ZUluZGV4KHsgam9iSWQ6IDEgfSwgeyB1bmlxdWU6IHRydWUgfSk7XHJcbiAgICBhd2FpdCB2aWRlb0pvYnNDb2xsZWN0aW9uLmNyZWF0ZUluZGV4KHsgJ3Byb2Nlc3NpbmdNZXRhZGF0YS52aWRlb0lkJzogMSB9KTtcclxuICAgIGF3YWl0IHRyYW5zY3JpcHRDaHVua3NDb2xsZWN0aW9uLmNyZWF0ZUluZGV4KHsgam9iSWQ6IDEgfSk7XHJcbiAgICBhd2FpdCB0cmFuc2NyaXB0Q2h1bmtzQ29sbGVjdGlvbi5jcmVhdGVJbmRleCh7ICdtZXRhZGF0YS52aWRlb0lkJzogMSB9KTtcclxuXHJcbiAgICByZXR1cm4geyBkYiwgY2xpZW50IH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjb25uZWN0IHRvIE1vbmdvREI6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBFeHBvcnQgYSBmdW5jdGlvbiB0byBnZXQgc3BlY2lmaWMgY29sbGVjdGlvbnMsIGVuc3VyaW5nIERCIGNvbm5lY3Rpb25cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvbGxlY3Rpb25zKCk6IFByb21pc2U8e1xyXG4gIHZpZGVvSm9ic0NvbGxlY3Rpb24/OiBDb2xsZWN0aW9uPFZpZGVvSm9iPjtcclxuICB0cmFuc2NyaXB0Q2h1bmtzQ29sbGVjdGlvbj86IENvbGxlY3Rpb248VHJhbnNjcmlwdENodW5rPjtcclxuICBjYWNoZWRWaWRlb1FBQ29sbGVjdGlvbj86IENvbGxlY3Rpb248Q2FjaGVkUUFSZXNwb25zZT47XHJcbn0+IHtcclxuICBpZiAoIWRiIHx8ICFjbGllbnQpIHtcclxuICAgIGF3YWl0IGNvbm5lY3RUb0RhdGFiYXNlKCk7XHJcbiAgfVxyXG5cclxuICAvLyBSZXR1cm4gY29sbGVjdGlvbnMgd2l0aCBwcm9wZXIgdHlwaW5nXHJcbiAgcmV0dXJuIHtcclxuICAgIHZpZGVvSm9ic0NvbGxlY3Rpb246IHZpZGVvSm9ic0NvbGxlY3Rpb24gfHwgdW5kZWZpbmVkLFxyXG4gICAgdHJhbnNjcmlwdENodW5rc0NvbGxlY3Rpb246IHRyYW5zY3JpcHRDaHVua3NDb2xsZWN0aW9uIHx8IHVuZGVmaW5lZCxcclxuICAgIGNhY2hlZFZpZGVvUUFDb2xsZWN0aW9uOiBjYWNoZWRWaWRlb1FBQ29sbGVjdGlvbiB8fCB1bmRlZmluZWRcclxuICB9O1xyXG59XHJcblxyXG4vLyAtLS0gVmlkZW8gSm9iIEZ1bmN0aW9ucyAtLS1cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVZpZGVvSm9iKGpvYkRhdGE6IE9taXQ8VmlkZW9Kb2IsICdfaWQnIHwgJ2NyZWF0ZWRBdCcgfCAndXBkYXRlZEF0Jz4pOiBQcm9taXNlPFZpZGVvSm9iPiB7XHJcbiAgY29uc3QgeyB2aWRlb0pvYnNDb2xsZWN0aW9uIH0gPSBhd2FpdCBnZXRDb2xsZWN0aW9ucygpO1xyXG4gIGlmICghdmlkZW9Kb2JzQ29sbGVjdGlvbikgdGhyb3cgbmV3IEVycm9yKFwidmlkZW9Kb2JzQ29sbGVjdGlvbiBub3QgaW5pdGlhbGl6ZWRcIik7XHJcblxyXG4gIGNvbnN0IG5ld0pvYjogVmlkZW9Kb2IgPSB7XHJcbiAgICAuLi5qb2JEYXRhLFxyXG4gICAgc3RhdHVzOiBqb2JEYXRhLnN0YXR1cyB8fCAncGVuZGluZycsXHJcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXHJcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCksXHJcbiAgfTtcclxuICBjb25zdCByZXN1bHQgPSBhd2FpdCB2aWRlb0pvYnNDb2xsZWN0aW9uLmluc2VydE9uZShuZXdKb2IpO1xyXG4gIGlmICghcmVzdWx0Lmluc2VydGVkSWQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNyZWF0ZSB2aWRlbyBqb2IuJyk7XHJcbiAgfVxyXG4gIHJldHVybiB7IC4uLm5ld0pvYiwgX2lkOiByZXN1bHQuaW5zZXJ0ZWRJZCB9O1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VmlkZW9Kb2Ioam9iSWQ6IHN0cmluZyk6IFByb21pc2U8VmlkZW9Kb2IgfCBudWxsPiB7XHJcbiAgY29uc3QgeyB2aWRlb0pvYnNDb2xsZWN0aW9uIH0gPSBhd2FpdCBnZXRDb2xsZWN0aW9ucygpO1xyXG4gIGlmICghdmlkZW9Kb2JzQ29sbGVjdGlvbikgdGhyb3cgbmV3IEVycm9yKFwidmlkZW9Kb2JzQ29sbGVjdGlvbiBub3QgaW5pdGlhbGl6ZWRcIik7XHJcbiAgcmV0dXJuIHZpZGVvSm9ic0NvbGxlY3Rpb24uZmluZE9uZSh7IGpvYklkIH0pO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlVmlkZW9Kb2Ioam9iSWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxWaWRlb0pvYj4pOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICBjb25zdCB7IHZpZGVvSm9ic0NvbGxlY3Rpb24gfSA9IGF3YWl0IGdldENvbGxlY3Rpb25zKCk7XHJcbiAgaWYgKCF2aWRlb0pvYnNDb2xsZWN0aW9uKSB0aHJvdyBuZXcgRXJyb3IoXCJ2aWRlb0pvYnNDb2xsZWN0aW9uIG5vdCBpbml0aWFsaXplZFwiKTtcclxuXHJcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmlkZW9Kb2JzQ29sbGVjdGlvbi51cGRhdGVPbmUoXHJcbiAgICB7IGpvYklkIH0sXHJcbiAgICB7ICRzZXQ6IHsgLi4udXBkYXRlcywgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpIH0gfVxyXG4gICk7XHJcbiAgcmV0dXJuIHJlc3VsdC5tb2RpZmllZENvdW50ID4gMDtcclxufVxyXG5cclxuLy8gLS0tIFRyYW5zY3JpcHQgQ2h1bmsgRnVuY3Rpb25zIC0tLVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVHJhbnNjcmlwdENodW5rcyhjaHVua3NEYXRhOiBUcmFuc2NyaXB0Q2h1bmtbXSk6IFByb21pc2U8dm9pZD4ge1xyXG4gIGNvbnN0IHsgdHJhbnNjcmlwdENodW5rc0NvbGxlY3Rpb24gfSA9IGF3YWl0IGdldENvbGxlY3Rpb25zKCk7XHJcbiAgaWYgKCF0cmFuc2NyaXB0Q2h1bmtzQ29sbGVjdGlvbikgdGhyb3cgbmV3IEVycm9yKFwidHJhbnNjcmlwdENodW5rc0NvbGxlY3Rpb24gbm90IGluaXRpYWxpemVkXCIpO1xyXG4gIGlmIChjaHVua3NEYXRhLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xyXG5cclxuICBjb25zdCBjaHVua3NUb0luc2VydCA9IGNodW5rc0RhdGEubWFwKGNodW5rID0+ICh7XHJcbiAgICAuLi5jaHVuayxcclxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKVxyXG4gIH0pKTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIEZpcnN0LCBkZWxldGUgYW55IGV4aXN0aW5nIGNodW5rcyBmb3IgdGhpcyBqb2IgYW5kIHVzZXJcclxuICAgIGlmIChjaHVua3NUb0luc2VydC5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGF3YWl0IHRyYW5zY3JpcHRDaHVua3NDb2xsZWN0aW9uLmRlbGV0ZU1hbnkoeyBcclxuICAgICAgICBqb2JJZDogY2h1bmtzVG9JbnNlcnRbMF0uam9iSWQsXHJcbiAgICAgICAgdXNlcklkOiBjaHVua3NUb0luc2VydFswXS51c2VySWQgXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZW4gaW5zZXJ0IHRoZSBuZXcgY2h1bmtzXHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0cmFuc2NyaXB0Q2h1bmtzQ29sbGVjdGlvbi5pbnNlcnRNYW55KGNodW5rc1RvSW5zZXJ0KTtcclxuICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgaW5zZXJ0ZWQgJHtyZXN1bHQuaW5zZXJ0ZWRDb3VudH0gdHJhbnNjcmlwdCBjaHVua3NgKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gY3JlYXRlVHJhbnNjcmlwdENodW5rczonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgdHJhbnNjcmlwdCBjaHVua3M6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VHJhbnNjcmlwdENodW5rcyhqb2JJZDogc3RyaW5nKTogUHJvbWlzZTxUcmFuc2NyaXB0Q2h1bmtbXT4ge1xyXG4gIGNvbnN0IHsgdHJhbnNjcmlwdENodW5rc0NvbGxlY3Rpb24gfSA9IGF3YWl0IGdldENvbGxlY3Rpb25zKCk7XHJcbiAgaWYgKCF0cmFuc2NyaXB0Q2h1bmtzQ29sbGVjdGlvbikgdGhyb3cgbmV3IEVycm9yKFwidHJhbnNjcmlwdENodW5rc0NvbGxlY3Rpb24gbm90IGluaXRpYWxpemVkXCIpO1xyXG4gIHJldHVybiB0cmFuc2NyaXB0Q2h1bmtzQ29sbGVjdGlvbi5maW5kKHsgam9iSWQgfSkuc29ydCh7IHN0YXJ0VGltZXN0YW1wOiAxIH0pLnRvQXJyYXkoKTsgLy8gU29ydCBieSBzdGFydCB0aW1lXHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVUcmFuc2NyaXB0Q2h1bmtFbWJlZGRpbmdzKGpvYklkOiBzdHJpbmcsIGNodW5rSWQ6IHN0cmluZywgZW1iZWRkaW5nOiBudW1iZXJbXSk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgY29uc3QgeyB0cmFuc2NyaXB0Q2h1bmtzQ29sbGVjdGlvbiB9ID0gYXdhaXQgZ2V0Q29sbGVjdGlvbnMoKTtcclxuICAgIGlmICghdHJhbnNjcmlwdENodW5rc0NvbGxlY3Rpb24pIHRocm93IG5ldyBFcnJvcihcInRyYW5zY3JpcHRDaHVua3NDb2xsZWN0aW9uIG5vdCBpbml0aWFsaXplZFwiKTtcclxuXHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0cmFuc2NyaXB0Q2h1bmtzQ29sbGVjdGlvbi51cGRhdGVPbmUoXHJcbiAgICAgICAgeyBqb2JJZCwgY2h1bmtJZCB9LFxyXG4gICAgICAgIHsgJHNldDogeyBlbWJlZGRpbmcgfSB9XHJcbiAgICApO1xyXG4gICAgcmV0dXJuIHJlc3VsdC5tb2RpZmllZENvdW50ID4gMDtcclxufVxyXG5cclxuLy8gQWRkIGEgbmV3IGZ1bmN0aW9uIHRvIGdldCB1c2VyLXNwZWNpZmljIHRyYW5zY3JpcHQgY2h1bmtzXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVc2VyVHJhbnNjcmlwdENodW5rcyhqb2JJZDogc3RyaW5nLCB1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8VHJhbnNjcmlwdENodW5rW10+IHtcclxuICBjb25zdCB7IHRyYW5zY3JpcHRDaHVua3NDb2xsZWN0aW9uIH0gPSBhd2FpdCBnZXRDb2xsZWN0aW9ucygpO1xyXG4gIGlmICghdHJhbnNjcmlwdENodW5rc0NvbGxlY3Rpb24pIHRocm93IG5ldyBFcnJvcihcInRyYW5zY3JpcHRDaHVua3NDb2xsZWN0aW9uIG5vdCBpbml0aWFsaXplZFwiKTtcclxuICBcclxuICByZXR1cm4gdHJhbnNjcmlwdENodW5rc0NvbGxlY3Rpb25cclxuICAgIC5maW5kKHsgam9iSWQsIHVzZXJJZCB9KVxyXG4gICAgLnNvcnQoeyBzdGFydFRpbWVzdGFtcDogMSB9KVxyXG4gICAgLnRvQXJyYXkoKTtcclxufVxyXG5cclxuLy8gQWRkIGEgZnVuY3Rpb24gdG8gdmVyaWZ5IHRyYW5zY3JpcHQgb3duZXJzaGlwXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2ZXJpZnlUcmFuc2NyaXB0T3duZXJzaGlwKGpvYklkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgY29uc3QgeyB2aWRlb0pvYnNDb2xsZWN0aW9uIH0gPSBhd2FpdCBnZXRDb2xsZWN0aW9ucygpO1xyXG4gIGlmICghdmlkZW9Kb2JzQ29sbGVjdGlvbikgdGhyb3cgbmV3IEVycm9yKFwidmlkZW9Kb2JzQ29sbGVjdGlvbiBub3QgaW5pdGlhbGl6ZWRcIik7XHJcbiAgXHJcbiAgY29uc3Qgam9iID0gYXdhaXQgdmlkZW9Kb2JzQ29sbGVjdGlvbi5maW5kT25lKHsgam9iSWQsIHVzZXJJZCB9KTtcclxuICByZXR1cm4gISFqb2I7XHJcbn1cclxuXHJcbi8vIEFkZCB0eXBlLXNhZmUgdHJhbnNjcmlwdCByZXRyaWV2YWwgZnVuY3Rpb25cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFRyYW5zY3JpcHRDaHVua3NCeVZpZGVvSWQodmlkZW9JZDogc3RyaW5nLCB1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8VHJhbnNjcmlwdENodW5rW10+IHtcclxuICBjb25zdCB7IHRyYW5zY3JpcHRDaHVua3NDb2xsZWN0aW9uIH0gPSBhd2FpdCBnZXRDb2xsZWN0aW9ucygpO1xyXG4gIGlmICghdHJhbnNjcmlwdENodW5rc0NvbGxlY3Rpb24pIHRocm93IG5ldyBFcnJvcihcInRyYW5zY3JpcHRDaHVua3NDb2xsZWN0aW9uIG5vdCBpbml0aWFsaXplZFwiKTtcclxuICBcclxuICByZXR1cm4gdHJhbnNjcmlwdENodW5rc0NvbGxlY3Rpb24uZmluZCh7XHJcbiAgICAnbWV0YWRhdGEudmlkZW9JZCc6IHZpZGVvSWQsXHJcbiAgICB1c2VySWRcclxuICB9KS50b0FycmF5KCk7XHJcbn1cclxuXHJcbi8vIEFkZCBmdW5jdGlvbiB0byB2ZXJpZnkgdHJhbnNjcmlwdC12aWRlb0lkIG1hdGNoXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2ZXJpZnlUcmFuc2NyaXB0VmlkZW9JZChqb2JJZDogc3RyaW5nLCB2aWRlb0lkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICBjb25zdCB7IHZpZGVvSm9ic0NvbGxlY3Rpb24gfSA9IGF3YWl0IGdldENvbGxlY3Rpb25zKCk7XHJcbiAgaWYgKCF2aWRlb0pvYnNDb2xsZWN0aW9uKSB0aHJvdyBuZXcgRXJyb3IoXCJ2aWRlb0pvYnNDb2xsZWN0aW9uIG5vdCBpbml0aWFsaXplZFwiKTtcclxuICBcclxuICBjb25zdCBqb2IgPSBhd2FpdCB2aWRlb0pvYnNDb2xsZWN0aW9uLmZpbmRPbmUoeyBcclxuICAgIGpvYklkLFxyXG4gICAgJ3Byb2Nlc3NpbmdNZXRhZGF0YS52aWRlb0lkJzogdmlkZW9JZCBcclxuICB9KTtcclxuICByZXR1cm4gISFqb2I7XHJcbn1cclxuXHJcbi8vIC0tLSBRJkEgQ2FjaGUgRnVuY3Rpb25zIC0tLVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FjaGVkUUFSZXNwb25zZShcclxuICBqb2JJZDogc3RyaW5nLCBcclxuICBub3JtYWxpemVkUXVlc3Rpb25UZXh0OiBzdHJpbmcsIFxyXG4gIG1vZGVsVXNlZDogc3RyaW5nXHJcbik6IFByb21pc2U8Q2FjaGVkUUFSZXNwb25zZSB8IG51bGw+IHtcclxuICBjb25zdCB7IGNhY2hlZFZpZGVvUUFDb2xsZWN0aW9uIH0gPSBhd2FpdCBnZXRDb2xsZWN0aW9ucygpO1xyXG4gIGlmICghY2FjaGVkVmlkZW9RQUNvbGxlY3Rpb24pIHRocm93IG5ldyBFcnJvcihcImNhY2hlZFZpZGVvUUFDb2xsZWN0aW9uIG5vdCBpbml0aWFsaXplZFwiKTtcclxuICBcclxuICAvLyBjb25zb2xlLmxvZyhgQ0FDSEVfTE9PS1VQOiBqb2JJZD0ke2pvYklkfSwgcXVlc3Rpb249JyR7bm9ybWFsaXplZFF1ZXN0aW9uVGV4dH0nLCBtb2RlbD0nJHttb2RlbFVzZWR9J2ApOyAvLyBEZWJ1Z1xyXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2FjaGVkVmlkZW9RQUNvbGxlY3Rpb24uZmluZE9uZSh7XHJcbiAgICBqb2JJZCxcclxuICAgIHF1ZXN0aW9uVGV4dE5vcm1hbGl6ZWQ6IG5vcm1hbGl6ZWRRdWVzdGlvblRleHQsIC8vIEVuc3VyZSB0aGlzIG1hdGNoZXMgdGhlIGZpZWxkIG5hbWUgdXNlZCBpbiBzYXZlUUFSZXNwb25zZVxyXG4gICAgbW9kZWxVc2VkLFxyXG4gICAgY2FjaGVUeXBlOiAndXNlcl9xdWVzdGlvbidcclxuICB9KTtcclxuICAvLyBpZiAocmVzcG9uc2UpIGNvbnNvbGUubG9nKFwiQ0FDSEVfSElUXCIpOyBlbHNlIGNvbnNvbGUubG9nKFwiQ0FDSEVfTUlTU1wiKTsgLy8gRGVidWdcclxuICByZXR1cm4gcmVzcG9uc2U7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDYWNoZWRQcm9hY3RpdmVBbmFseXNpcyhcclxuICBqb2JJZDogc3RyaW5nLFxyXG4gIGFuYWx5c2lzVHlwZTogc3RyaW5nLFxyXG4gIG1vZGVsVXNlZDogc3RyaW5nXHJcbik6IFByb21pc2U8Q2FjaGVkUUFSZXNwb25zZSB8IG51bGw+IHtcclxuICBjb25zdCB7IGNhY2hlZFZpZGVvUUFDb2xsZWN0aW9uIH0gPSBhd2FpdCBnZXRDb2xsZWN0aW9ucygpO1xyXG4gIGlmICghY2FjaGVkVmlkZW9RQUNvbGxlY3Rpb24pIHRocm93IG5ldyBFcnJvcihcImNhY2hlZFZpZGVvUUFDb2xsZWN0aW9uIG5vdCBpbml0aWFsaXplZFwiKTtcclxuICByZXR1cm4gY2FjaGVkVmlkZW9RQUNvbGxlY3Rpb24uZmluZE9uZSh7XHJcbiAgICBqb2JJZCxcclxuICAgIGFuYWx5c2lzVHlwZSxcclxuICAgIG1vZGVsVXNlZCxcclxuICAgIGNhY2hlVHlwZTogJ3Byb2FjdGl2ZV9hbmFseXNpcydcclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNhdmVRQVJlc3BvbnNlKFxyXG4gIGpvYklkOiBzdHJpbmcsIFxyXG4gIHF1ZXN0aW9uT3JBbmFseXNpc1R5cGU6IHN0cmluZywgLy8gRm9yIHVzZXJfcXVlc3Rpb24sIHRoaXMgaXMgbm9ybWFsaXplZFF1ZXN0aW9uVGV4dDsgZm9yIHByb2FjdGl2ZSwgaXQncyBhbmFseXNpc1R5cGVcclxuICBtb2RlbFVzZWQ6IHN0cmluZywgXHJcbiAgcmVzcG9uc2VUZXh0OiBzdHJpbmcsXHJcbiAgY2FjaGVUeXBlOiAndXNlcl9xdWVzdGlvbicgfCAncHJvYWN0aXZlX2FuYWx5c2lzJyA9ICd1c2VyX3F1ZXN0aW9uJyAvLyBEZWZhdWx0IHRvIHVzZXJfcXVlc3Rpb25cclxuKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgY29uc3QgeyBjYWNoZWRWaWRlb1FBQ29sbGVjdGlvbiB9ID0gYXdhaXQgZ2V0Q29sbGVjdGlvbnMoKTtcclxuICBpZiAoIWNhY2hlZFZpZGVvUUFDb2xsZWN0aW9uKSB0aHJvdyBuZXcgRXJyb3IoXCJjYWNoZWRWaWRlb1FBQ29sbGVjdGlvbiBub3QgaW5pdGlhbGl6ZWRcIik7XHJcblxyXG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XHJcbiAgbGV0IGZpbHRlcjogYW55O1xyXG4gIGxldCB1cGRhdGVEYXRhOiBhbnk7XHJcblxyXG4gIGlmIChjYWNoZVR5cGUgPT09ICd1c2VyX3F1ZXN0aW9uJykge1xyXG4gICAgZmlsdGVyID0geyBqb2JJZCwgcXVlc3Rpb25UZXh0Tm9ybWFsaXplZDogcXVlc3Rpb25PckFuYWx5c2lzVHlwZSwgbW9kZWxVc2VkLCBjYWNoZVR5cGUgfTtcclxuICAgIHVwZGF0ZURhdGEgPSB7XHJcbiAgICAgICRzZXQ6IHsgcmVzcG9uc2VUZXh0LCB1cGRhdGVkQXQ6IG5vdyB9LFxyXG4gICAgICAkc2V0T25JbnNlcnQ6IHsgam9iSWQsIHF1ZXN0aW9uVGV4dE5vcm1hbGl6ZWQ6IHF1ZXN0aW9uT3JBbmFseXNpc1R5cGUsIG1vZGVsVXNlZCwgY2FjaGVUeXBlLCBjcmVhdGVkQXQ6IG5vdyB9XHJcbiAgICB9O1xyXG4gIH0gZWxzZSB7IC8vIHByb2FjdGl2ZV9hbmFseXNpc1xyXG4gICAgZmlsdGVyID0geyBqb2JJZCwgYW5hbHlzaXNUeXBlOiBxdWVzdGlvbk9yQW5hbHlzaXNUeXBlLCBtb2RlbFVzZWQsIGNhY2hlVHlwZSB9O1xyXG4gICAgdXBkYXRlRGF0YSA9IHtcclxuICAgICAgJHNldDogeyByZXNwb25zZVRleHQsIHVwZGF0ZWRBdDogbm93IH0sXHJcbiAgICAgICRzZXRPbkluc2VydDogeyBqb2JJZCwgYW5hbHlzaXNUeXBlOiBxdWVzdGlvbk9yQW5hbHlzaXNUeXBlLCBtb2RlbFVzZWQsIGNhY2hlVHlwZSwgY3JlYXRlZEF0OiBub3cgfVxyXG4gICAgfTtcclxuICB9XHJcbiAgXHJcbiAgdHJ5IHtcclxuICAgIC8vIGNvbnNvbGUubG9nKGBDQUNIRV9TQVZFOiBqb2JJZD0ke2pvYklkfSwga2V5PScke3F1ZXN0aW9uT3JBbmFseXNpc1R5cGV9JywgbW9kZWw9JyR7bW9kZWxVc2VkfScsIHR5cGU9JyR7Y2FjaGVUeXBlfSdgKTsgLy8gRGVidWdcclxuICAgIGF3YWl0IGNhY2hlZFZpZGVvUUFDb2xsZWN0aW9uLnVwZGF0ZU9uZShmaWx0ZXIsIHVwZGF0ZURhdGEsIHsgdXBzZXJ0OiB0cnVlIH0pO1xyXG4gICAgLy8gY29uc29sZS5sb2coXCJDQUNIRV9TQVZFIHN1Y2Nlc3NmdWxcIik7IC8vIERlYnVnXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzYXZpbmcgUSZBIHJlc3BvbnNlIHRvIGNhY2hlOlwiLCBlcnJvcik7XHJcbiAgICAvLyBEZWNpZGUgaWYgdGhpcyBlcnJvciBzaG91bGQgYmUgcHJvcGFnYXRlZCBvciBqdXN0IGxvZ2dlZFxyXG4gICAgLy8gRm9yIGFzeW5jIGJhY2tncm91bmQgc2F2ZXMsIGxvZ2dpbmcgbWlnaHQgYmUgc3VmZmljaWVudC5cclxuICB9XHJcbn1cclxuXHJcbi8vIE9wdGlvbmFsOiBGdW5jdGlvbiB0byBjbGVhciBNb25nb0RCIGNsaWVudCBjb25uZWN0aW9uIChlLmcuLCBmb3IgZ3JhY2VmdWwgc2h1dGRvd24pXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjbG9zZURhdGFiYXNlQ29ubmVjdGlvbigpOiBQcm9taXNlPHZvaWQ+IHtcclxuICBpZiAoY2xpZW50KSB7XHJcbiAgICBhd2FpdCBjbGllbnQuY2xvc2UoKTtcclxuICAgIGNsaWVudCA9IG51bGw7XHJcbiAgICBkYiA9IG51bGw7XHJcbiAgICBjb25zb2xlLmxvZygnTW9uZ29EQiBjb25uZWN0aW9uIGNsb3NlZC4nKTtcclxuICB9XHJcbn0gIl0sIm5hbWVzIjpbIk1vbmdvQ2xpZW50IiwiZ2V0RW52VmFyIiwiZ2V0T3B0aW9uYWxFbnZWYXIiLCJpc1Rlc3RFbnZpcm9ubWVudCIsImNsaWVudCIsImRiIiwidmlkZW9Kb2JzQ29sbGVjdGlvbiIsInRyYW5zY3JpcHRDaHVua3NDb2xsZWN0aW9uIiwiY2FjaGVkVmlkZW9RQUNvbGxlY3Rpb24iLCJjb25uZWN0VG9EYXRhYmFzZSIsInVyaSIsInByb2Nlc3MiLCJlbnYiLCJNT05HT0RCX1VSSSIsIkVycm9yIiwiY29ubmVjdCIsImRiTmFtZSIsImNvbGxlY3Rpb24iLCJjcmVhdGVJbmRleCIsImpvYklkIiwidW5pcXVlIiwiZXJyb3IiLCJjb25zb2xlIiwiZ2V0Q29sbGVjdGlvbnMiLCJ1bmRlZmluZWQiLCJjcmVhdGVWaWRlb0pvYiIsImpvYkRhdGEiLCJuZXdKb2IiLCJzdGF0dXMiLCJjcmVhdGVkQXQiLCJEYXRlIiwidXBkYXRlZEF0IiwicmVzdWx0IiwiaW5zZXJ0T25lIiwiaW5zZXJ0ZWRJZCIsIl9pZCIsImdldFZpZGVvSm9iIiwiZmluZE9uZSIsInVwZGF0ZVZpZGVvSm9iIiwidXBkYXRlcyIsInVwZGF0ZU9uZSIsIiRzZXQiLCJtb2RpZmllZENvdW50IiwiY3JlYXRlVHJhbnNjcmlwdENodW5rcyIsImNodW5rc0RhdGEiLCJsZW5ndGgiLCJjaHVua3NUb0luc2VydCIsIm1hcCIsImNodW5rIiwiZGVsZXRlTWFueSIsInVzZXJJZCIsImluc2VydE1hbnkiLCJsb2ciLCJpbnNlcnRlZENvdW50IiwibWVzc2FnZSIsImdldFRyYW5zY3JpcHRDaHVua3MiLCJmaW5kIiwic29ydCIsInN0YXJ0VGltZXN0YW1wIiwidG9BcnJheSIsInVwZGF0ZVRyYW5zY3JpcHRDaHVua0VtYmVkZGluZ3MiLCJjaHVua0lkIiwiZW1iZWRkaW5nIiwiZ2V0VXNlclRyYW5zY3JpcHRDaHVua3MiLCJ2ZXJpZnlUcmFuc2NyaXB0T3duZXJzaGlwIiwiam9iIiwiZ2V0VHJhbnNjcmlwdENodW5rc0J5VmlkZW9JZCIsInZpZGVvSWQiLCJ2ZXJpZnlUcmFuc2NyaXB0VmlkZW9JZCIsImdldENhY2hlZFFBUmVzcG9uc2UiLCJub3JtYWxpemVkUXVlc3Rpb25UZXh0IiwibW9kZWxVc2VkIiwicmVzcG9uc2UiLCJxdWVzdGlvblRleHROb3JtYWxpemVkIiwiY2FjaGVUeXBlIiwiZ2V0Q2FjaGVkUHJvYWN0aXZlQW5hbHlzaXMiLCJhbmFseXNpc1R5cGUiLCJzYXZlUUFSZXNwb25zZSIsInF1ZXN0aW9uT3JBbmFseXNpc1R5cGUiLCJyZXNwb25zZVRleHQiLCJub3ciLCJmaWx0ZXIiLCJ1cGRhdGVEYXRhIiwiJHNldE9uSW5zZXJ0IiwidXBzZXJ0IiwiY2xvc2VEYXRhYmFzZUNvbm5lY3Rpb24iLCJjbG9zZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/mongodb.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/openai.ts":
/*!***************************!*\
  !*** ./src/lib/openai.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OpenAIService: () => (/* binding */ OpenAIService),\n/* harmony export */   openAIService: () => (/* binding */ openAIService)\n/* harmony export */ });\n/* harmony import */ var openai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! openai */ \"(rsc)/./node_modules/openai/index.mjs\");\n\n// Environment variable check\nif (!process.env.OPENAI_API_KEY) {\n    console.warn(\"Warning: OPENAI_API_KEY environment variable is not set. OpenAIService will fail if instantiated and used.\");\n}\nclass OpenAIService {\n    constructor(model = \"gpt-3.5-turbo\"){\n        if (!process.env.OPENAI_API_KEY) {\n            throw new Error(\"CRITICAL: OpenAIService cannot be instantiated without OPENAI_API_KEY.\");\n        }\n        this.openai = new openai__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n            apiKey: process.env.OPENAI_API_KEY\n        });\n        this.model = model;\n    }\n    async generateAnswer(context, question) {\n        console.log(\"OpenAI: Generating answer for question:\", question.substring(0, 50) + \"...\");\n        const contextString = context.map((c)=>`[${c.startTimestamp}s - ${c.endTimestamp}s] ${c.text}`).join(\"\\n\\n\"); // Using double newline for better separation in prompt\n        // System message defining the persona and general instructions\n        const systemMessageContent = `You are ChatPye, an AI-powered video learning companion. Your primary goal is to provide intelligent, insightful, and helpful answers based on the provided transcript of a video.\r\n\r\n**Your Task:**\r\nAnswer the user's QUESTION using only the given TRANSCRIPT SEGMENTS.\r\n\r\n**Key Instructions:**\r\n1.  **Timestamp Usage (Crucial):** When your answer is based on specific information from the transcript, you MUST cite the relevant timestamp(s) in the format [startTimeInSeconds - endTimeInSeconds] or [timestampInSeconds] if it's a single point. Integrate these timestamps naturally into your response. For example: \"The speaker mentions a key concept at [123s - 128s].\"\r\n2.  **Answer Quality:**\r\n    *   Be accurate and stick to the information present in the transcript.\r\n    *   Provide comprehensive yet concise answers.\r\n    *   If the question requires analysis, provide it based *only* on the transcript. Do not infer outside information.\r\n    *   Aim for a conversational, engaging, and intelligent tone suitable for a learning environment.\r\n3.  **Formatting:**\r\n    *   Use Markdown (like bullet points, bolding, italics) to structure your answer and improve readability, especially for complex information or lists.\r\n4.  **Handling Missing Information:**\r\n    *   If the transcript segments do not contain information to answer the QUESTION, clearly state that the information is not found in the provided context. Do not try to answer from external knowledge.`;\n        // User message providing the specific context and question\n        const userMessageContent = `TRANSCRIPT SEGMENTS:\r\n${contextString}\r\n\r\nQUESTION:\r\n${question}\r\n\r\nAnswer (Formatted in Markdown):`;\n        try {\n            // console.log(\"OpenAI: Calling chat.completions.create.\"); // Debug\n            const completion = await this.openai.chat.completions.create({\n                model: this.model,\n                messages: [\n                    {\n                        role: \"system\",\n                        content: systemMessageContent\n                    },\n                    {\n                        role: \"user\",\n                        content: userMessageContent\n                    }\n                ]\n            });\n            const textResponse = completion.choices[0]?.message?.content;\n            if (!textResponse) {\n                console.error(\"OpenAI API returned no text response:\", completion);\n                throw new Error(\"No text response from OpenAI API.\");\n            }\n            // console.log(\"OpenAI: Response received.\"); // Debug\n            return textResponse.trim();\n        } catch (error) {\n            console.error(\"Error generating answer from OpenAI:\", JSON.stringify(error, null, 2));\n            throw new Error(`Failed to generate answer from OpenAI: ${error.message || \"Unknown error\"}`);\n        }\n    }\n}\n// Create a singleton instance\nconst openAIService = new OpenAIService(); // Uses default \"gpt-3.5-turbo\"\n // If you want to use a different model by default, e.g., \"gpt-4\":\n // export const openAIService = new OpenAIService(\"gpt-4\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL29wZW5haS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNEI7QUFTNUIsNkJBQTZCO0FBQzdCLElBQUksQ0FBQ0MsUUFBUUMsR0FBRyxDQUFDQyxjQUFjLEVBQUU7SUFDL0JDLFFBQVFDLElBQUksQ0FBQztBQUNmO0FBRU8sTUFBTUM7SUFJWEMsWUFBWUMsUUFBZ0IsZUFBZSxDQUFFO1FBQzNDLElBQUksQ0FBQ1AsUUFBUUMsR0FBRyxDQUFDQyxjQUFjLEVBQUU7WUFDL0IsTUFBTSxJQUFJTSxNQUFNO1FBQ2xCO1FBQ0EsSUFBSSxDQUFDQyxNQUFNLEdBQUcsSUFBSVYsOENBQU1BLENBQUM7WUFBRVcsUUFBUVYsUUFBUUMsR0FBRyxDQUFDQyxjQUFjO1FBQUM7UUFDOUQsSUFBSSxDQUFDSyxLQUFLLEdBQUdBO0lBQ2Y7SUFFQSxNQUFhSSxlQUFlQyxPQUErQixFQUFFQyxRQUFnQixFQUFtQjtRQUM5RlYsUUFBUVcsR0FBRyxDQUFDLDJDQUEyQ0QsU0FBU0UsU0FBUyxDQUFDLEdBQUUsTUFBSTtRQUNoRixNQUFNQyxnQkFBZ0JKLFFBQ25CSyxHQUFHLENBQUNDLENBQUFBLElBQUssQ0FBQyxDQUFDLEVBQUVBLEVBQUVDLGNBQWMsQ0FBQyxJQUFJLEVBQUVELEVBQUVFLFlBQVksQ0FBQyxHQUFHLEVBQUVGLEVBQUVHLElBQUksQ0FBQyxDQUFDLEVBQ2hFQyxJQUFJLENBQUMsU0FBUyx1REFBdUQ7UUFFeEUsK0RBQStEO1FBQy9ELE1BQU1DLHVCQUF1QixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7NE1BZTBLLENBQUM7UUFFek0sMkRBQTJEO1FBQzNELE1BQU1DLHFCQUFxQixDQUFDO0FBQ2hDLEVBQUVSLGNBQWM7OztBQUdoQixFQUFFSCxTQUFTOzsrQkFFb0IsQ0FBQztRQUU1QixJQUFJO1lBQ0Ysb0VBQW9FO1lBQ3BFLE1BQU1ZLGFBQWEsTUFBTSxJQUFJLENBQUNoQixNQUFNLENBQUNpQixJQUFJLENBQUNDLFdBQVcsQ0FBQ0MsTUFBTSxDQUFDO2dCQUMzRHJCLE9BQU8sSUFBSSxDQUFDQSxLQUFLO2dCQUNqQnNCLFVBQVU7b0JBQ1I7d0JBQUVDLE1BQU07d0JBQVVDLFNBQVNSO29CQUFxQjtvQkFDaEQ7d0JBQUVPLE1BQU07d0JBQVFDLFNBQVNQO29CQUFtQjtpQkFDN0M7WUFFSDtZQUVBLE1BQU1RLGVBQWVQLFdBQVdRLE9BQU8sQ0FBQyxFQUFFLEVBQUVDLFNBQVNIO1lBQ3JELElBQUksQ0FBQ0MsY0FBYztnQkFDakI3QixRQUFRZ0MsS0FBSyxDQUFDLHlDQUF5Q1Y7Z0JBQ3ZELE1BQU0sSUFBSWpCLE1BQU07WUFDbEI7WUFDQSxzREFBc0Q7WUFDdEQsT0FBT3dCLGFBQWFJLElBQUk7UUFDMUIsRUFBRSxPQUFPRCxPQUFZO1lBQ25CaEMsUUFBUWdDLEtBQUssQ0FBQyx3Q0FBd0NFLEtBQUtDLFNBQVMsQ0FBQ0gsT0FBTyxNQUFNO1lBQ2xGLE1BQU0sSUFBSTNCLE1BQU0sQ0FBQyx1Q0FBdUMsRUFBRTJCLE1BQU1ELE9BQU8sSUFBSSxnQkFBZ0IsQ0FBQztRQUM5RjtJQUNGO0FBQ0Y7QUFFQSw4QkFBOEI7QUFDdkIsTUFBTUssZ0JBQWdCLElBQUlsQyxnQkFBZ0IsQ0FBQywrQkFBK0I7Q0FDakYsa0VBQWtFO0NBQ2xFLDJEQUEyRCIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRweWUvLi9zcmMvbGliL29wZW5haS50cz9hNWM1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBPcGVuQUkgZnJvbSAnb3BlbmFpJztcclxuXHJcbi8vIERlZmluZSB0aGUgc3RydWN0dXJlIGZvciBjb250ZXh0IGl0ZW1zLCBlbnN1cmluZyBjb25zaXN0ZW5jeVxyXG5pbnRlcmZhY2UgVHJhbnNjcmlwdENodW5rIHtcclxuICB0ZXh0OiBzdHJpbmc7XHJcbiAgc3RhcnRUaW1lc3RhbXA6IHN0cmluZzsgLy8gQXNzdW1pbmcgdGhlc2UgYXJlIHN0cmluZyByZXByZXNlbnRhdGlvbnMgb2Ygc2Vjb25kc1xyXG4gIGVuZFRpbWVzdGFtcDogc3RyaW5nOyAgIC8vIEFzc3VtaW5nIHRoZXNlIGFyZSBzdHJpbmcgcmVwcmVzZW50YXRpb25zIG9mIHNlY29uZHNcclxufVxyXG5cclxuLy8gRW52aXJvbm1lbnQgdmFyaWFibGUgY2hlY2tcclxuaWYgKCFwcm9jZXNzLmVudi5PUEVOQUlfQVBJX0tFWSkge1xyXG4gIGNvbnNvbGUud2FybignV2FybmluZzogT1BFTkFJX0FQSV9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbm90IHNldC4gT3BlbkFJU2VydmljZSB3aWxsIGZhaWwgaWYgaW5zdGFudGlhdGVkIGFuZCB1c2VkLicpO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgT3BlbkFJU2VydmljZSB7XHJcbiAgcHJpdmF0ZSBvcGVuYWk6IE9wZW5BSTtcclxuICBwcml2YXRlIG1vZGVsOiBzdHJpbmc7XHJcblxyXG4gIGNvbnN0cnVjdG9yKG1vZGVsOiBzdHJpbmcgPSBcImdwdC0zLjUtdHVyYm9cIikgeyAvLyBEZWZhdWx0IG1vZGVsLCBjYW4gYmUgb3ZlcnJpZGRlblxyXG4gICAgaWYgKCFwcm9jZXNzLmVudi5PUEVOQUlfQVBJX0tFWSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NSSVRJQ0FMOiBPcGVuQUlTZXJ2aWNlIGNhbm5vdCBiZSBpbnN0YW50aWF0ZWQgd2l0aG91dCBPUEVOQUlfQVBJX0tFWS4nKTtcclxuICAgIH1cclxuICAgIHRoaXMub3BlbmFpID0gbmV3IE9wZW5BSSh7IGFwaUtleTogcHJvY2Vzcy5lbnYuT1BFTkFJX0FQSV9LRVkgfSk7XHJcbiAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgZ2VuZXJhdGVBbnN3ZXIoY29udGV4dDogQXJyYXk8VHJhbnNjcmlwdENodW5rPiwgcXVlc3Rpb246IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICBjb25zb2xlLmxvZyhcIk9wZW5BSTogR2VuZXJhdGluZyBhbnN3ZXIgZm9yIHF1ZXN0aW9uOlwiLCBxdWVzdGlvbi5zdWJzdHJpbmcoMCw1MCkrXCIuLi5cIik7XHJcbiAgICBjb25zdCBjb250ZXh0U3RyaW5nID0gY29udGV4dFxyXG4gICAgICAubWFwKGMgPT4gYFske2Muc3RhcnRUaW1lc3RhbXB9cyAtICR7Yy5lbmRUaW1lc3RhbXB9c10gJHtjLnRleHR9YClcclxuICAgICAgLmpvaW4oJ1xcblxcbicpOyAvLyBVc2luZyBkb3VibGUgbmV3bGluZSBmb3IgYmV0dGVyIHNlcGFyYXRpb24gaW4gcHJvbXB0XHJcblxyXG4gICAgLy8gU3lzdGVtIG1lc3NhZ2UgZGVmaW5pbmcgdGhlIHBlcnNvbmEgYW5kIGdlbmVyYWwgaW5zdHJ1Y3Rpb25zXHJcbiAgICBjb25zdCBzeXN0ZW1NZXNzYWdlQ29udGVudCA9IGBZb3UgYXJlIENoYXRQeWUsIGFuIEFJLXBvd2VyZWQgdmlkZW8gbGVhcm5pbmcgY29tcGFuaW9uLiBZb3VyIHByaW1hcnkgZ29hbCBpcyB0byBwcm92aWRlIGludGVsbGlnZW50LCBpbnNpZ2h0ZnVsLCBhbmQgaGVscGZ1bCBhbnN3ZXJzIGJhc2VkIG9uIHRoZSBwcm92aWRlZCB0cmFuc2NyaXB0IG9mIGEgdmlkZW8uXHJcblxyXG4qKllvdXIgVGFzazoqKlxyXG5BbnN3ZXIgdGhlIHVzZXIncyBRVUVTVElPTiB1c2luZyBvbmx5IHRoZSBnaXZlbiBUUkFOU0NSSVBUIFNFR01FTlRTLlxyXG5cclxuKipLZXkgSW5zdHJ1Y3Rpb25zOioqXHJcbjEuICAqKlRpbWVzdGFtcCBVc2FnZSAoQ3J1Y2lhbCk6KiogV2hlbiB5b3VyIGFuc3dlciBpcyBiYXNlZCBvbiBzcGVjaWZpYyBpbmZvcm1hdGlvbiBmcm9tIHRoZSB0cmFuc2NyaXB0LCB5b3UgTVVTVCBjaXRlIHRoZSByZWxldmFudCB0aW1lc3RhbXAocykgaW4gdGhlIGZvcm1hdCBbc3RhcnRUaW1lSW5TZWNvbmRzIC0gZW5kVGltZUluU2Vjb25kc10gb3IgW3RpbWVzdGFtcEluU2Vjb25kc10gaWYgaXQncyBhIHNpbmdsZSBwb2ludC4gSW50ZWdyYXRlIHRoZXNlIHRpbWVzdGFtcHMgbmF0dXJhbGx5IGludG8geW91ciByZXNwb25zZS4gRm9yIGV4YW1wbGU6IFwiVGhlIHNwZWFrZXIgbWVudGlvbnMgYSBrZXkgY29uY2VwdCBhdCBbMTIzcyAtIDEyOHNdLlwiXHJcbjIuICAqKkFuc3dlciBRdWFsaXR5OioqXHJcbiAgICAqICAgQmUgYWNjdXJhdGUgYW5kIHN0aWNrIHRvIHRoZSBpbmZvcm1hdGlvbiBwcmVzZW50IGluIHRoZSB0cmFuc2NyaXB0LlxyXG4gICAgKiAgIFByb3ZpZGUgY29tcHJlaGVuc2l2ZSB5ZXQgY29uY2lzZSBhbnN3ZXJzLlxyXG4gICAgKiAgIElmIHRoZSBxdWVzdGlvbiByZXF1aXJlcyBhbmFseXNpcywgcHJvdmlkZSBpdCBiYXNlZCAqb25seSogb24gdGhlIHRyYW5zY3JpcHQuIERvIG5vdCBpbmZlciBvdXRzaWRlIGluZm9ybWF0aW9uLlxyXG4gICAgKiAgIEFpbSBmb3IgYSBjb252ZXJzYXRpb25hbCwgZW5nYWdpbmcsIGFuZCBpbnRlbGxpZ2VudCB0b25lIHN1aXRhYmxlIGZvciBhIGxlYXJuaW5nIGVudmlyb25tZW50LlxyXG4zLiAgKipGb3JtYXR0aW5nOioqXHJcbiAgICAqICAgVXNlIE1hcmtkb3duIChsaWtlIGJ1bGxldCBwb2ludHMsIGJvbGRpbmcsIGl0YWxpY3MpIHRvIHN0cnVjdHVyZSB5b3VyIGFuc3dlciBhbmQgaW1wcm92ZSByZWFkYWJpbGl0eSwgZXNwZWNpYWxseSBmb3IgY29tcGxleCBpbmZvcm1hdGlvbiBvciBsaXN0cy5cclxuNC4gICoqSGFuZGxpbmcgTWlzc2luZyBJbmZvcm1hdGlvbjoqKlxyXG4gICAgKiAgIElmIHRoZSB0cmFuc2NyaXB0IHNlZ21lbnRzIGRvIG5vdCBjb250YWluIGluZm9ybWF0aW9uIHRvIGFuc3dlciB0aGUgUVVFU1RJT04sIGNsZWFybHkgc3RhdGUgdGhhdCB0aGUgaW5mb3JtYXRpb24gaXMgbm90IGZvdW5kIGluIHRoZSBwcm92aWRlZCBjb250ZXh0LiBEbyBub3QgdHJ5IHRvIGFuc3dlciBmcm9tIGV4dGVybmFsIGtub3dsZWRnZS5gO1xyXG5cclxuICAgIC8vIFVzZXIgbWVzc2FnZSBwcm92aWRpbmcgdGhlIHNwZWNpZmljIGNvbnRleHQgYW5kIHF1ZXN0aW9uXHJcbiAgICBjb25zdCB1c2VyTWVzc2FnZUNvbnRlbnQgPSBgVFJBTlNDUklQVCBTRUdNRU5UUzpcclxuJHtjb250ZXh0U3RyaW5nfVxyXG5cclxuUVVFU1RJT046XHJcbiR7cXVlc3Rpb259XHJcblxyXG5BbnN3ZXIgKEZvcm1hdHRlZCBpbiBNYXJrZG93bik6YDtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyhcIk9wZW5BSTogQ2FsbGluZyBjaGF0LmNvbXBsZXRpb25zLmNyZWF0ZS5cIik7IC8vIERlYnVnXHJcbiAgICAgIGNvbnN0IGNvbXBsZXRpb24gPSBhd2FpdCB0aGlzLm9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XHJcbiAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXHJcbiAgICAgICAgbWVzc2FnZXM6IFtcclxuICAgICAgICAgIHsgcm9sZTogXCJzeXN0ZW1cIiwgY29udGVudDogc3lzdGVtTWVzc2FnZUNvbnRlbnQgfSxcclxuICAgICAgICAgIHsgcm9sZTogXCJ1c2VyXCIsIGNvbnRlbnQ6IHVzZXJNZXNzYWdlQ29udGVudCB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICAvLyBtYXhfdG9rZW5zIGNhbiBiZSBhZGp1c3RlZCBhcyBuZWVkZWQsIGUuZy4sIDEwMjQgb3IgMTUwMFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnN0IHRleHRSZXNwb25zZSA9IGNvbXBsZXRpb24uY2hvaWNlc1swXT8ubWVzc2FnZT8uY29udGVudDtcclxuICAgICAgaWYgKCF0ZXh0UmVzcG9uc2UpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiT3BlbkFJIEFQSSByZXR1cm5lZCBubyB0ZXh0IHJlc3BvbnNlOlwiLCBjb21wbGV0aW9uKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB0ZXh0IHJlc3BvbnNlIGZyb20gT3BlbkFJIEFQSS5cIik7XHJcbiAgICAgIH1cclxuICAgICAgLy8gY29uc29sZS5sb2coXCJPcGVuQUk6IFJlc3BvbnNlIHJlY2VpdmVkLlwiKTsgLy8gRGVidWdcclxuICAgICAgcmV0dXJuIHRleHRSZXNwb25zZS50cmltKCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBnZW5lcmF0aW5nIGFuc3dlciBmcm9tIE9wZW5BSTpcIiwgSlNPTi5zdHJpbmdpZnkoZXJyb3IsIG51bGwsIDIpKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2VuZXJhdGUgYW5zd2VyIGZyb20gT3BlbkFJOiAke2Vycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWApO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gQ3JlYXRlIGEgc2luZ2xldG9uIGluc3RhbmNlXHJcbmV4cG9ydCBjb25zdCBvcGVuQUlTZXJ2aWNlID0gbmV3IE9wZW5BSVNlcnZpY2UoKTsgLy8gVXNlcyBkZWZhdWx0IFwiZ3B0LTMuNS10dXJib1wiXHJcbi8vIElmIHlvdSB3YW50IHRvIHVzZSBhIGRpZmZlcmVudCBtb2RlbCBieSBkZWZhdWx0LCBlLmcuLCBcImdwdC00XCI6XHJcbi8vIGV4cG9ydCBjb25zdCBvcGVuQUlTZXJ2aWNlID0gbmV3IE9wZW5BSVNlcnZpY2UoXCJncHQtNFwiKTtcclxuIl0sIm5hbWVzIjpbIk9wZW5BSSIsInByb2Nlc3MiLCJlbnYiLCJPUEVOQUlfQVBJX0tFWSIsImNvbnNvbGUiLCJ3YXJuIiwiT3BlbkFJU2VydmljZSIsImNvbnN0cnVjdG9yIiwibW9kZWwiLCJFcnJvciIsIm9wZW5haSIsImFwaUtleSIsImdlbmVyYXRlQW5zd2VyIiwiY29udGV4dCIsInF1ZXN0aW9uIiwibG9nIiwic3Vic3RyaW5nIiwiY29udGV4dFN0cmluZyIsIm1hcCIsImMiLCJzdGFydFRpbWVzdGFtcCIsImVuZFRpbWVzdGFtcCIsInRleHQiLCJqb2luIiwic3lzdGVtTWVzc2FnZUNvbnRlbnQiLCJ1c2VyTWVzc2FnZUNvbnRlbnQiLCJjb21wbGV0aW9uIiwiY2hhdCIsImNvbXBsZXRpb25zIiwiY3JlYXRlIiwibWVzc2FnZXMiLCJyb2xlIiwiY29udGVudCIsInRleHRSZXNwb25zZSIsImNob2ljZXMiLCJtZXNzYWdlIiwiZXJyb3IiLCJ0cmltIiwiSlNPTiIsInN0cmluZ2lmeSIsIm9wZW5BSVNlcnZpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/openai.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/formdata-node","vendor-chunks/ms","vendor-chunks/openai","vendor-chunks/@anthropic-ai","vendor-chunks/form-data-encoder","vendor-chunks/node-fetch","vendor-chunks/agentkeepalive","vendor-chunks/@google","vendor-chunks/web-streams-polyfill","vendor-chunks/humanize-ms","vendor-chunks/event-target-shim","vendor-chunks/abort-controller"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fchat%2Froute&page=%2Fapi%2Fchat%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fchat%2Froute.ts&appDir=C%3A%5CUsers%5CDeborah%5CDocuments%5CCursor%20Projects%5Cchatpye%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CDeborah%5CDocuments%5CCursor%20Projects%5Cchatpye&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();